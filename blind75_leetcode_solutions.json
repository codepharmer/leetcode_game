{
  "1": {
    "question_name": "Two Sum",
    "general_solution_pattern": "Hash map lookup",
    "specific_solution_pattern": "Single-pass complement map (value -> index)",
    "general_type": "Arrays & Hashing",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def twoSum(self, nums, target):",
      "        seen = {}",
      "        for i, x in enumerate(nums):",
      "            need = target - x",
      "            if need in seen:",
      "                return [seen[need], i]",
      "            seen[x] = i"
    ],
    "intuition": "As you scan left-to-right, remember where you've seen each value. For the current value x, the only partner that works is target-x; if it was seen earlier, you have the answer immediately."
  },
  "3": {
    "question_name": "Longest Substring Without Repeating Characters",
    "general_solution_pattern": "Sliding window",
    "specific_solution_pattern": "Last-seen index map; move left past duplicates",
    "general_type": "String",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def lengthOfLongestSubstring(self, s):",
      "        last = {}",
      "        left = 0",
      "        best = 0",
      "",
      "        for right, ch in enumerate(s):",
      "            if ch in last and last[ch] >= left:",
      "                left = last[ch] + 1",
      "            last[ch] = right",
      "            best = max(best, right - left + 1)",
      "",
      "        return best"
    ],
    "intuition": "Maintain a window with all unique chars. When you see a repeated char, the window must jump its left boundary to one past the previous occurrence."
  },
  "5": {
    "question_name": "Longest Palindromic Substring",
    "general_solution_pattern": "String algorithm (Manacher)",
    "specific_solution_pattern": "Transform with separators; compute palindrome radii in O(n)",
    "general_type": "String",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def longestPalindrome(self, s):",
      "        if not s:",
      "            return \"\"",
      "",
      "        # Transform to handle even/odd uniformly: \"^#a#b#...#$\"",
      "        t = \"^#\" + \"#\".join(s) + \"#$\"",
      "        p = [0] * len(t)",
      "        center = right = 0",
      "",
      "        for i in range(1, len(t) - 1):",
      "            mirror = 2 * center - i",
      "            if i < right:",
      "                p[i] = min(right - i, p[mirror])",
      "",
      "            while t[i + 1 + p[i]] == t[i - 1 - p[i]]:",
      "                p[i] += 1",
      "",
      "            if i + p[i] > right:",
      "                center, right = i, i + p[i]",
      "",
      "        max_len = 0",
      "        center_idx = 0",
      "        for i, r in enumerate(p):",
      "            if r > max_len:",
      "                max_len = r",
      "                center_idx = i",
      "",
      "        start = (center_idx - max_len) // 2",
      "        return s[start:start + max_len]"
    ],
    "intuition": "Manacher’s algorithm reuses information from previously found palindromes: a palindrome around center implies a mirrored palindrome on the other side. This lets you expand only when necessary and achieve linear time."
  },
  "11": {
    "question_name": "Container With Most Water",
    "general_solution_pattern": "Two pointers + greedy",
    "specific_solution_pattern": "Move the shorter wall inward",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def maxArea(self, height):",
      "        l, r = 0, len(height) - 1",
      "        best = 0",
      "        while l < r:",
      "            best = max(best, (r - l) * min(height[l], height[r]))",
      "            if height[l] < height[r]:",
      "                l += 1",
      "            else:",
      "                r -= 1",
      "        return best"
    ],
    "intuition": "The area is limited by the shorter line. Moving the taller line can only shrink width without raising the limit, so the only hope is to move the shorter line and possibly find a taller one."
  },
  "15": {
    "question_name": "3Sum",
    "general_solution_pattern": "Sorting + two pointers",
    "specific_solution_pattern": "Fix one value, then 2-sum sweep with duplicate skipping",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def threeSum(self, nums):",
      "        nums.sort()",
      "        res = []",
      "        n = len(nums)",
      "",
      "        for i in range(n):",
      "            if i > 0 and nums[i] == nums[i - 1]:",
      "                continue",
      "            if nums[i] > 0:",
      "                break",
      "",
      "            l, r = i + 1, n - 1",
      "            while l < r:",
      "                s = nums[i] + nums[l] + nums[r]",
      "                if s == 0:",
      "                    res.append([nums[i], nums[l], nums[r]])",
      "                    l += 1",
      "                    r -= 1",
      "                    while l < r and nums[l] == nums[l - 1]:",
      "                        l += 1",
      "                    while l < r and nums[r] == nums[r + 1]:",
      "                        r -= 1",
      "                elif s < 0:",
      "                    l += 1",
      "                else:",
      "                    r -= 1",
      "",
      "        return res"
    ],
    "intuition": "After sorting, for a fixed i the remaining two numbers must sum to -nums[i]. Two pointers can find those pairs in linear time, and skipping equal values prevents duplicate triplets."
  },
  "19": {
    "question_name": "Remove Nth Node From End of List",
    "general_solution_pattern": "Two pointers",
    "specific_solution_pattern": "Maintain a gap of n between fast and slow pointers",
    "general_type": "Linked List",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def removeNthFromEnd(self, head, n):",
      "        dummy = ListNode(0, head)",
      "        fast = slow = dummy",
      "",
      "        for _ in range(n):",
      "            fast = fast.next",
      "",
      "        while fast.next:",
      "            fast = fast.next",
      "            slow = slow.next",
      "",
      "        slow.next = slow.next.next",
      "        return dummy.next"
    ],
    "intuition": "If fast is n nodes ahead of slow, then when fast reaches the end, slow is right before the node to remove. The dummy node makes removing the head node easy."
  },
  "20": {
    "question_name": "Valid Parentheses",
    "general_solution_pattern": "Stack",
    "specific_solution_pattern": "Push expected closing bracket; pop to match",
    "general_type": "String",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def isValid(self, s):",
      "        match = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}",
      "        stack = []",
      "",
      "        for ch in s:",
      "            if ch in match:",
      "                stack.append(match[ch])",
      "            else:",
      "                if not stack or stack.pop() != ch:",
      "                    return False",
      "",
      "        return not stack"
    ],
    "intuition": "The most recent unmatched opening bracket must be closed next (LIFO). Pushing the expected closer makes mismatches easy to detect."
  },
  "21": {
    "question_name": "Merge Two Sorted Lists",
    "general_solution_pattern": "Merge process",
    "specific_solution_pattern": "Iterative merge with dummy head",
    "general_type": "Linked List",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def mergeTwoLists(self, list1, list2):",
      "        dummy = ListNode(0)",
      "        tail = dummy",
      "",
      "        while list1 and list2:",
      "            if list1.val <= list2.val:",
      "                tail.next, list1 = list1, list1.next",
      "            else:",
      "                tail.next, list2 = list2, list2.next",
      "            tail = tail.next",
      "",
      "        tail.next = list1 or list2",
      "        return dummy.next"
    ],
    "intuition": "Like merging two sorted arrays: repeatedly take the smaller head node and advance that list. A dummy head simplifies edge cases."
  },
  "23": {
    "question_name": "Merge k Sorted Lists",
    "general_solution_pattern": "Heap / k-way merge",
    "specific_solution_pattern": "Min-heap of (node.val, list_id, node); pop/push next",
    "general_type": "Linked List",
    "difficulty": "Hard",
    "code_solution": [
      "import heapq",
      "",
      "class Solution:",
      "    def mergeKLists(self, lists):",
      "        heap = []",
      "        for i, node in enumerate(lists):",
      "            if node:",
      "                heapq.heappush(heap, (node.val, i, node))",
      "",
      "        dummy = ListNode(0)",
      "        tail = dummy",
      "",
      "        while heap:",
      "            val, i, node = heapq.heappop(heap)",
      "            tail.next = node",
      "            tail = tail.next",
      "            if node.next:",
      "                heapq.heappush(heap, (node.next.val, i, node.next))",
      "",
      "        tail.next = None",
      "        return dummy.next"
    ],
    "intuition": "You always want the smallest current head among k lists. A min-heap gives that in O(log k), and after popping one node you push its successor from the same list."
  },
  "33": {
    "question_name": "Search in Rotated Sorted Array",
    "general_solution_pattern": "Modified binary search",
    "specific_solution_pattern": "Identify sorted half; keep half that could contain target",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def search(self, nums, target):",
      "        l, r = 0, len(nums) - 1",
      "        while l <= r:",
      "            m = (l + r) // 2",
      "            if nums[m] == target:",
      "                return m",
      "",
      "            if nums[l] <= nums[m]:  # left half sorted",
      "                if nums[l] <= target < nums[m]:",
      "                    r = m - 1",
      "                else:",
      "                    l = m + 1",
      "            else:  # right half sorted",
      "                if nums[m] < target <= nums[r]:",
      "                    l = m + 1",
      "                else:",
      "                    r = m - 1",
      "        return -1"
    ],
    "intuition": "At any time, at least one side of mid is normally sorted. If the target falls inside that sorted range, you binary search there; otherwise it must be in the other half."
  },
  "39": {
    "question_name": "Combination Sum",
    "general_solution_pattern": "Backtracking / DFS",
    "specific_solution_pattern": "Sorted candidates + prune; allow reuse by not advancing index",
    "general_type": "Backtracking",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def combinationSum(self, candidates, target):",
      "        candidates.sort()",
      "        res = []",
      "        path = []",
      "",
      "        def dfs(start, remaining):",
      "            if remaining == 0:",
      "                res.append(path[:])",
      "                return",
      "            for i in range(start, len(candidates)):",
      "                c = candidates[i]",
      "                if c > remaining:",
      "                    break",
      "                path.append(c)",
      "                dfs(i, remaining - c)  # reuse allowed",
      "                path.pop()",
      "",
      "        dfs(0, target)",
      "        return res"
    ],
    "intuition": "You build combinations in non-decreasing order to avoid duplicates. Sorting lets you stop early when a candidate exceeds the remaining target."
  },
  "48": {
    "question_name": "Rotate Image",
    "general_solution_pattern": "In-place matrix transform",
    "specific_solution_pattern": "Transpose then reverse each row",
    "general_type": "Matrix",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def rotate(self, matrix):",
      "        n = len(matrix)",
      "",
      "        for r in range(n):",
      "            for c in range(r + 1, n):",
      "                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]",
      "",
      "        for r in range(n):",
      "            matrix[r].reverse()"
    ],
    "intuition": "A 90° clockwise rotation equals reflecting across the main diagonal (transpose) and then reflecting each row horizontally (reverse)."
  },
  "49": {
    "question_name": "Group Anagrams",
    "general_solution_pattern": "Hashing by canonical signature",
    "specific_solution_pattern": "Use 26-count tuple as key (lowercase letters)",
    "general_type": "String",
    "difficulty": "Medium",
    "code_solution": [
      "from collections import defaultdict",
      "",
      "class Solution:",
      "    def groupAnagrams(self, strs):",
      "        groups = defaultdict(list)",
      "",
      "        for s in strs:",
      "            counts = [0] * 26",
      "            for ch in s:",
      "                counts[ord(ch) - ord(\"a\")] += 1",
      "            groups[tuple(counts)].append(s)",
      "",
      "        return list(groups.values())"
    ],
    "intuition": "Anagrams share the same multiset of letters. A frequency vector is a canonical representation of that multiset, so it’s a perfect hash key."
  },
  "53": {
    "question_name": "Maximum Subarray",
    "general_solution_pattern": "Dynamic programming (1D) / Kadane",
    "specific_solution_pattern": "Best subarray ending here = max(start new, extend)",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def maxSubArray(self, nums):",
      "        best_end = nums[0]",
      "        best = nums[0]",
      "        for x in nums[1:]:",
      "            best_end = max(x, best_end + x)",
      "            best = max(best, best_end)",
      "        return best"
    ],
    "intuition": "A subarray either helps you (positive sum so far) or hurts you (negative sum so far). If the running sum becomes worse than starting fresh at x, you restart; track the best seen."
  },
  "54": {
    "question_name": "Spiral Matrix",
    "general_solution_pattern": "Boundary simulation",
    "specific_solution_pattern": "Shrink top/bottom/left/right bounds layer by layer",
    "general_type": "Matrix",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def spiralOrder(self, matrix):",
      "        if not matrix or not matrix[0]:",
      "            return []",
      "",
      "        top, bottom = 0, len(matrix) - 1",
      "        left, right = 0, len(matrix[0]) - 1",
      "        res = []",
      "",
      "        while top <= bottom and left <= right:",
      "            for c in range(left, right + 1):",
      "                res.append(matrix[top][c])",
      "            top += 1",
      "",
      "            for r in range(top, bottom + 1):",
      "                res.append(matrix[r][right])",
      "            right -= 1",
      "",
      "            if top <= bottom:",
      "                for c in range(right, left - 1, -1):",
      "                    res.append(matrix[bottom][c])",
      "                bottom -= 1",
      "",
      "            if left <= right:",
      "                for r in range(bottom, top - 1, -1):",
      "                    res.append(matrix[r][left])",
      "                left += 1",
      "",
      "        return res"
    ],
    "intuition": "A spiral is just repeatedly taking the top row, right column, bottom row, and left column, then moving the boundaries inward."
  },
  "55": {
    "question_name": "Jump Game",
    "general_solution_pattern": "Greedy reachability",
    "specific_solution_pattern": "Track farthest reachable index; fail if i > farthest",
    "general_type": "Greedy",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def canJump(self, nums):",
      "        farthest = 0",
      "        for i, jump in enumerate(nums):",
      "            if i > farthest:",
      "                return False",
      "            farthest = max(farthest, i + jump)",
      "        return True"
    ],
    "intuition": "You don’t need to decide exact jumps; you only need to know the farthest index you can reach so far. If you ever land on an index beyond that, it’s unreachable."
  },
  "56": {
    "question_name": "Merge Intervals",
    "general_solution_pattern": "Sort + merge sweep",
    "specific_solution_pattern": "Sort by start; merge into last if overlapping",
    "general_type": "Intervals",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def merge(self, intervals):",
      "        if not intervals:",
      "            return []",
      "        intervals.sort(key=lambda x: x[0])",
      "        res = [intervals[0]]",
      "        for s, e in intervals[1:]:",
      "            if s <= res[-1][1]:",
      "                res[-1][1] = max(res[-1][1], e)",
      "            else:",
      "                res.append([s, e])",
      "        return res"
    ],
    "intuition": "After sorting by start time, any overlap can only happen with the most recently merged interval. So a single pass is enough."
  },
  "57": {
    "question_name": "Insert Interval",
    "general_solution_pattern": "Interval sweep/merge",
    "specific_solution_pattern": "Add non-overlapping left, merge overlaps with new interval, then add right",
    "general_type": "Intervals",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def insert(self, intervals, newInterval):",
      "        res = []",
      "        i = 0",
      "        n = len(intervals)",
      "",
      "        # intervals completely before newInterval",
      "        while i < n and intervals[i][1] < newInterval[0]:",
      "            res.append(intervals[i])",
      "            i += 1",
      "",
      "        # merge overlaps",
      "        start, end = newInterval",
      "        while i < n and intervals[i][0] <= end:",
      "            start = min(start, intervals[i][0])",
      "            end = max(end, intervals[i][1])",
      "            i += 1",
      "        res.append([start, end])",
      "",
      "        # intervals after",
      "        while i < n:",
      "            res.append(intervals[i])",
      "            i += 1",
      "",
      "        return res"
    ],
    "intuition": "Because intervals are sorted and non-overlapping, you can process them in order: everything before the new interval stays as-is, everything overlapping merges into one, and everything after stays as-is."
  },
  "62": {
    "question_name": "Unique Paths",
    "general_solution_pattern": "Combinatorics / DP",
    "specific_solution_pattern": "Compute binomial coefficient C((m+n-2),(m-1)) iteratively",
    "general_type": "Dynamic Programming",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def uniquePaths(self, m, n):",
      "        total = (m - 1) + (n - 1)",
      "        k = min(m - 1, n - 1)",
      "        res = 1",
      "        for i in range(1, k + 1):",
      "            res = res * (total - k + i) // i",
      "        return res"
    ],
    "intuition": "Any path is a sequence of (m-1) downs and (n-1) rights in some order. Choosing which positions are downs uniquely determines the path."
  },
  "70": {
    "question_name": "Climbing Stairs",
    "general_solution_pattern": "DP / Fibonacci",
    "specific_solution_pattern": "ways[i] = ways[i-1] + ways[i-2] with O(1) space",
    "general_type": "Dynamic Programming",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def climbStairs(self, n):",
      "        if n <= 2:",
      "            return n",
      "        a, b = 1, 2",
      "        for _ in range(3, n + 1):",
      "            a, b = b, a + b",
      "        return b"
    ],
    "intuition": "To reach step i, your last move was from i-1 or i-2. So the count is the sum of those counts, which is Fibonacci."
  },
  "73": {
    "question_name": "Set Matrix Zeroes",
    "general_solution_pattern": "In-place marking",
    "specific_solution_pattern": "Use first row/col as markers + two flags",
    "general_type": "Matrix",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def setZeroes(self, matrix):",
      "        m, n = len(matrix), len(matrix[0])",
      "",
      "        first_row_zero = any(matrix[0][c] == 0 for c in range(n))",
      "        first_col_zero = any(matrix[r][0] == 0 for r in range(m))",
      "",
      "        for r in range(1, m):",
      "            for c in range(1, n):",
      "                if matrix[r][c] == 0:",
      "                    matrix[r][0] = 0",
      "                    matrix[0][c] = 0",
      "",
      "        for r in range(1, m):",
      "            for c in range(1, n):",
      "                if matrix[r][0] == 0 or matrix[0][c] == 0:",
      "                    matrix[r][c] = 0",
      "",
      "        if first_row_zero:",
      "            for c in range(n):",
      "                matrix[0][c] = 0",
      "        if first_col_zero:",
      "            for r in range(m):",
      "                matrix[r][0] = 0"
    ],
    "intuition": "Rows/cols that must become zero can be 'remembered' using the first cell of that row/col as a flag, avoiding extra memory. Two separate flags protect the original state of the first row/col."
  },
  "76": {
    "question_name": "Minimum Window Substring",
    "general_solution_pattern": "Sliding window with counting",
    "specific_solution_pattern": "Expand to satisfy counts, then shrink to minimal while valid",
    "general_type": "String",
    "difficulty": "Hard",
    "code_solution": [
      "from collections import Counter",
      "",
      "class Solution:",
      "    def minWindow(self, s, t):",
      "        if not t or not s:",
      "            return \"\"",
      "",
      "        need = Counter(t)",
      "        window = {}",
      "        formed = 0",
      "        required = len(need)",
      "",
      "        best_len = float(\"inf\")",
      "        best_l = 0",
      "",
      "        l = 0",
      "        for r, ch in enumerate(s):",
      "            window[ch] = window.get(ch, 0) + 1",
      "            if ch in need and window[ch] == need[ch]:",
      "                formed += 1",
      "",
      "            while formed == required:",
      "                if r - l + 1 < best_len:",
      "                    best_len = r - l + 1",
      "                    best_l = l",
      "",
      "                left_ch = s[l]",
      "                window[left_ch] -= 1",
      "                if left_ch in need and window[left_ch] < need[left_ch]:",
      "                    formed -= 1",
      "                l += 1",
      "",
      "        return \"\" if best_len == float(\"inf\") else s[best_l:best_l + best_len]"
    ],
    "intuition": "You expand the right end until the window contains all required characters (with multiplicity). Then you shrink from the left as much as possible while staying valid, recording the smallest valid window."
  },
  "79": {
    "question_name": "Word Search",
    "general_solution_pattern": "Backtracking on grid",
    "specific_solution_pattern": "DFS from each cell; mark visited in-place and restore",
    "general_type": "Matrix",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def exist(self, board, word):",
      "        if not board or not board[0]:",
      "            return False",
      "",
      "        m, n = len(board), len(board[0])",
      "",
      "        def dfs(r, c, i):",
      "            if i == len(word):",
      "                return True",
      "            if not (0 <= r < m and 0 <= c < n):",
      "                return False",
      "            if board[r][c] != word[i]:",
      "                return False",
      "",
      "            ch = board[r][c]",
      "            board[r][c] = \"#\"  # mark visited",
      "",
      "            found = (dfs(r + 1, c, i + 1) or",
      "                     dfs(r - 1, c, i + 1) or",
      "                     dfs(r, c + 1, i + 1) or",
      "                     dfs(r, c - 1, i + 1))",
      "",
      "            board[r][c] = ch",
      "            return found",
      "",
      "        for r in range(m):",
      "            for c in range(n):",
      "                if dfs(r, c, 0):",
      "                    return True",
      "        return False"
    ],
    "intuition": "Try to match the word character-by-character by walking to neighboring cells. Marking a cell as visited prevents reuse in the same path; restoring it enables other paths to use it."
  },
  "91": {
    "question_name": "Decode Ways",
    "general_solution_pattern": "DP over string positions",
    "specific_solution_pattern": "O(1) space: dp[i]=single-digit + two-digit contributions",
    "general_type": "Dynamic Programming",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def numDecodings(self, s):",
      "        if not s or s[0] == \"0\":",
      "            return 0",
      "",
      "        prev2, prev1 = 1, 1  # dp[i-2], dp[i-1]",
      "",
      "        for i in range(1, len(s)):",
      "            cur = 0",
      "",
      "            if s[i] != \"0\":",
      "                cur += prev1",
      "",
      "            two = int(s[i - 1:i + 1])",
      "            if 10 <= two <= 26:",
      "                cur += prev2",
      "",
      "            prev2, prev1 = prev1, cur",
      "",
      "        return prev1"
    ],
    "intuition": "A valid decode ending at i either uses s[i] as a single letter (if not '0') or uses s[i-1:i+1] as a two-digit letter (10–26). Add the number of ways from the appropriate earlier positions."
  },
  "98": {
    "question_name": "Validate Binary Search Tree",
    "general_solution_pattern": "DFS with invariants",
    "specific_solution_pattern": "Propagate allowable (min, max) range down the tree",
    "general_type": "Trees",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def isValidBST(self, root):",
      "        def dfs(node, lo, hi):",
      "            if not node:",
      "                return True",
      "            if not (lo < node.val < hi):",
      "                return False",
      "            return dfs(node.left, lo, node.val) and dfs(node.right, node.val, hi)",
      "",
      "        return dfs(root, float(\"-inf\"), float(\"inf\"))"
    ],
    "intuition": "BST rules are global: every node in the left subtree must be < root, not just the direct child. Carrying a valid range down ensures every node respects all ancestors’ constraints."
  },
  "100": {
    "question_name": "Same Tree",
    "general_solution_pattern": "Tree recursion",
    "specific_solution_pattern": "Compare node values and recursively compare subtrees",
    "general_type": "Trees",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def isSameTree(self, p, q):",
      "        if not p and not q:",
      "            return True",
      "        if not p or not q or p.val != q.val:",
      "            return False",
      "        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"
    ],
    "intuition": "Two trees are the same iff their roots match and their left subtrees are the same and their right subtrees are the same. Nulls must match too."
  },
  "102": {
    "question_name": "Binary Tree Level Order Traversal",
    "general_solution_pattern": "BFS",
    "specific_solution_pattern": "Queue by levels; process len(queue) nodes per level",
    "general_type": "Trees",
    "difficulty": "Medium",
    "code_solution": [
      "from collections import deque",
      "",
      "class Solution:",
      "    def levelOrder(self, root):",
      "        if not root:",
      "            return []",
      "",
      "        res = []",
      "        q = deque([root])",
      "",
      "        while q:",
      "            level = []",
      "            for _ in range(len(q)):",
      "                node = q.popleft()",
      "                level.append(node.val)",
      "                if node.left:",
      "                    q.append(node.left)",
      "                if node.right:",
      "                    q.append(node.right)",
      "            res.append(level)",
      "",
      "        return res"
    ],
    "intuition": "BFS visits nodes in increasing depth. If you process exactly the current queue length, you consume one full level before moving to the next."
  },
  "104": {
    "question_name": "Maximum Depth of Binary Tree",
    "general_solution_pattern": "Tree DFS",
    "specific_solution_pattern": "Depth = 1 + max(left, right)",
    "general_type": "Trees",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def maxDepth(self, root):",
      "        if not root:",
      "            return 0",
      "        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"
    ],
    "intuition": "The deepest path through a node must go through its deeper child. Recursively compute child depths and add 1 for the current node."
  },
  "105": {
    "question_name": "Construct Binary Tree from Preorder and Inorder Traversal",
    "general_solution_pattern": "Divide & conquer with hashmap",
    "specific_solution_pattern": "Use inorder index map to split; preorder pointer advances",
    "general_type": "Trees",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def buildTree(self, preorder, inorder):",
      "        idx = {v: i for i, v in enumerate(inorder)}",
      "        pre_i = 0",
      "",
      "        def helper(l, r):",
      "            nonlocal pre_i",
      "            if l > r:",
      "                return None",
      "",
      "            root_val = preorder[pre_i]",
      "            pre_i += 1",
      "            root = TreeNode(root_val)",
      "",
      "            mid = idx[root_val]",
      "            root.left = helper(l, mid - 1)",
      "            root.right = helper(mid + 1, r)",
      "            return root",
      "",
      "        return helper(0, len(inorder) - 1)"
    ],
    "intuition": "Preorder gives you the root first. In inorder, everything left of the root is the left subtree and everything right is the right subtree. A hashmap lets you find that split in O(1) each time."
  },
  "121": {
    "question_name": "Best Time to Buy and Sell Stock",
    "general_solution_pattern": "Greedy / running invariant",
    "specific_solution_pattern": "Track min price so far and best profit",
    "general_type": "Arrays & Hashing",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def maxProfit(self, prices):",
      "        min_price = float(\"inf\")",
      "        best = 0",
      "        for p in prices:",
      "            min_price = min(min_price, p)",
      "            best = max(best, p - min_price)",
      "        return best"
    ],
    "intuition": "If you sell on day i, the best buy day is simply the cheapest day before i. Keeping that minimum price lets you compute the best profit for every possible sell day in O(1)."
  },
  "124": {
    "question_name": "Binary Tree Maximum Path Sum",
    "general_solution_pattern": "Tree DP",
    "specific_solution_pattern": "Postorder gains + global best through each node",
    "general_type": "Trees",
    "difficulty": "Hard",
    "code_solution": [
      "class Solution:",
      "    def maxPathSum(self, root):",
      "        self.best = float(\"-inf\")",
      "",
      "        def gain(node):",
      "            if not node:",
      "                return 0",
      "            left = max(0, gain(node.left))",
      "            right = max(0, gain(node.right))",
      "",
      "            # path that peaks at node",
      "            self.best = max(self.best, node.val + left + right)",
      "",
      "            # best extendable path upward",
      "            return node.val + max(left, right)",
      "",
      "        gain(root)",
      "        return self.best"
    ],
    "intuition": "A maximum path either passes through a node as the highest point (taking best non-negative gains from both sides) or extends upward through one child. Compute 'best extendable gain' while updating a global answer for 'peak' paths."
  },
  "125": {
    "question_name": "Valid Palindrome",
    "general_solution_pattern": "Two pointers",
    "specific_solution_pattern": "Skip non-alphanumeric and compare lowercase chars",
    "general_type": "String",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def isPalindrome(self, s):",
      "        l, r = 0, len(s) - 1",
      "        while l < r:",
      "            while l < r and not s[l].isalnum():",
      "                l += 1",
      "            while l < r and not s[r].isalnum():",
      "                r -= 1",
      "            if s[l].lower() != s[r].lower():",
      "                return False",
      "            l += 1",
      "            r -= 1",
      "        return True"
    ],
    "intuition": "A palindrome reads the same forward and backward once you ignore irrelevant characters. Two pointers compare mirrored characters while skipping punctuation/spaces."
  },
  "128": {
    "question_name": "Longest Consecutive Sequence",
    "general_solution_pattern": "Hash set scanning",
    "specific_solution_pattern": "Only start counting at sequence starts (x-1 not in set)",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def longestConsecutive(self, nums):",
      "        s = set(nums)",
      "        best = 0",
      "        for x in s:",
      "            if x - 1 not in s:",
      "                y = x",
      "                while y in s:",
      "                    y += 1",
      "                best = max(best, y - x)",
      "        return best"
    ],
    "intuition": "If x isn’t preceded by x-1, it must be the start of a run. Each number is expanded at most once across all runs, giving linear expected time."
  },
  "133": {
    "question_name": "Clone Graph",
    "general_solution_pattern": "Graph traversal + hashmap",
    "specific_solution_pattern": "BFS/DFS with mapping original node -> cloned node",
    "general_type": "Graphs",
    "difficulty": "Medium",
    "code_solution": [
      "from collections import deque",
      "",
      "class Solution:",
      "    def cloneGraph(self, node):",
      "        if not node:",
      "            return None",
      "",
      "        clones = {node: type(node)(node.val)}",
      "        q = deque([node])",
      "",
      "        while q:",
      "            cur = q.popleft()",
      "            for nei in cur.neighbors:",
      "                if nei not in clones:",
      "                    clones[nei] = type(node)(nei.val)",
      "                    q.append(nei)",
      "                clones[cur].neighbors.append(clones[nei])",
      "",
      "        return clones[node]"
    ],
    "intuition": "Graphs can have cycles, so you must remember which nodes you’ve already cloned. The map ensures each original node is cloned once, and edges are recreated by linking clones."
  },
  "139": {
    "question_name": "Word Break",
    "general_solution_pattern": "DP feasibility",
    "specific_solution_pattern": "dp[i]=True if some dp[j] and s[j:i] in dict (bounded by max word length)",
    "general_type": "Binary Search / Greedy",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def wordBreak(self, s, wordDict):",
      "        words = set(wordDict)",
      "        max_len = max((len(w) for w in words), default=0)",
      "",
      "        dp = [False] * (len(s) + 1)",
      "        dp[0] = True",
      "",
      "        for i in range(1, len(s) + 1):",
      "            for j in range(max(0, i - max_len), i):",
      "                if dp[j] and s[j:i] in words:",
      "                    dp[i] = True",
      "                    break",
      "",
      "        return dp[len(s)]"
    ],
    "intuition": "dp[i] answers: can we segment the prefix s[:i]? If the last word ends at i and starts at j, then we need dp[j] and s[j:i] to be a dictionary word."
  },
  "141": {
    "question_name": "Linked List Cycle",
    "general_solution_pattern": "Two pointers",
    "specific_solution_pattern": "Floyd's tortoise-hare cycle detection",
    "general_type": "Linked List",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def hasCycle(self, head):",
      "        slow = fast = head",
      "        while fast and fast.next:",
      "            slow = slow.next",
      "            fast = fast.next.next",
      "            if slow is fast:",
      "                return True",
      "        return False"
    ],
    "intuition": "If there’s a cycle, a faster pointer moving 2 steps will eventually lap the slower pointer moving 1 step. If there’s no cycle, the fast pointer hits null."
  },
  "143": {
    "question_name": "Reorder List",
    "general_solution_pattern": "Split + reverse + merge",
    "specific_solution_pattern": "Find middle, reverse second half, then weave nodes alternating",
    "general_type": "Linked List",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def reorderList(self, head):",
      "        if not head or not head.next:",
      "            return",
      "",
      "        # 1) Find middle",
      "        slow = fast = head",
      "        while fast and fast.next:",
      "            slow = slow.next",
      "            fast = fast.next.next",
      "",
      "        # 2) Reverse second half",
      "        second = slow.next",
      "        slow.next = None",
      "        prev = None",
      "        while second:",
      "            nxt = second.next",
      "            second.next = prev",
      "            prev = second",
      "            second = nxt",
      "        second = prev",
      "",
      "        # 3) Merge alternating",
      "        first = head",
      "        while second:",
      "            f_next = first.next",
      "            s_next = second.next",
      "            first.next = second",
      "            second.next = f_next",
      "            first = f_next",
      "            second = s_next"
    ],
    "intuition": "The desired order is front, back, front, back... So you split the list in half, reverse the back half to make 'back' accessible in forward order, then weave the two lists together."
  },
  "152": {
    "question_name": "Maximum Product Subarray",
    "general_solution_pattern": "Dynamic programming (track extremes)",
    "specific_solution_pattern": "Maintain max and min product ending at i (swap on negative)",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def maxProduct(self, nums):",
      "        cur_max = cur_min = best = nums[0]",
      "        for x in nums[1:]:",
      "            if x < 0:",
      "                cur_max, cur_min = cur_min, cur_max",
      "            cur_max = max(x, cur_max * x)",
      "            cur_min = min(x, cur_min * x)",
      "            best = max(best, cur_max)",
      "        return best"
    ],
    "intuition": "A negative number can turn a small (very negative) product into the largest positive product. So you must track both the best and worst product ending at each position."
  },
  "153": {
    "question_name": "Find Minimum in Rotated Sorted Array",
    "general_solution_pattern": "Binary search on rotated invariant",
    "specific_solution_pattern": "Compare mid vs right to choose side containing pivot",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def findMin(self, nums):",
      "        l, r = 0, len(nums) - 1",
      "        while l < r:",
      "            m = (l + r) // 2",
      "            if nums[m] > nums[r]:",
      "                l = m + 1",
      "            else:",
      "                r = m",
      "        return nums[l]"
    ],
    "intuition": "In a rotated sorted array, one side around mid is still sorted. If nums[mid] > nums[right], the minimum must be to the right of mid; otherwise it’s at mid or left of it."
  },
  "190": {
    "question_name": "Reverse Bits",
    "general_solution_pattern": "Bit manipulation",
    "specific_solution_pattern": "Shift-accumulate for 32 steps",
    "general_type": "Binary",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def reverseBits(self, n):",
      "        res = 0",
      "        for _ in range(32):",
      "            res = (res << 1) | (n & 1)",
      "            n >>= 1",
      "        return res"
    ],
    "intuition": "Read bits from right to left (n&1) and build the reversed number by shifting the result left and appending the next bit."
  },
  "191": {
    "question_name": "Number of 1 Bits",
    "general_solution_pattern": "Bit trick",
    "specific_solution_pattern": "Brian Kernighan: n &= n-1 clears lowest set bit",
    "general_type": "Binary",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def hammingWeight(self, n):",
      "        count = 0",
      "        while n:",
      "            n &= n - 1",
      "            count += 1",
      "        return count"
    ],
    "intuition": "Subtracting 1 flips the lowest 1-bit to 0 (and turns trailing zeros into ones). ANDing with the original clears exactly that lowest 1-bit, so the loop runs once per set bit."
  },
  "198": {
    "question_name": "House Robber",
    "general_solution_pattern": "DP (take/skip)",
    "specific_solution_pattern": "Two variables: take = prev_skip + x, skip = max(prev_take, prev_skip)",
    "general_type": "Dynamic Programming",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def rob(self, nums):",
      "        take = 0",
      "        skip = 0",
      "        for x in nums:",
      "            new_take = skip + x",
      "            new_skip = max(skip, take)",
      "            take, skip = new_take, new_skip",
      "        return max(take, skip)"
    ],
    "intuition": "At each house you either rob it (so you must have skipped the previous) or skip it (so you keep the best so far). This local choice fully captures the constraint."
  },
  "200": {
    "question_name": "Number of Islands",
    "general_solution_pattern": "Connected components on grid",
    "specific_solution_pattern": "Flood-fill (BFS/DFS) each unvisited land cell",
    "general_type": "Graphs",
    "difficulty": "Medium",
    "code_solution": [
      "from collections import deque",
      "",
      "class Solution:",
      "    def numIslands(self, grid):",
      "        if not grid or not grid[0]:",
      "            return 0",
      "",
      "        m, n = len(grid), len(grid[0])",
      "        seen = set()",
      "",
      "        def bfs(sr, sc):",
      "            q = deque([(sr, sc)])",
      "            seen.add((sr, sc))",
      "            while q:",
      "                r, c = q.popleft()",
      "                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):",
      "                    nr, nc = r + dr, c + dc",
      "                    if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in seen and grid[nr][nc] == \"1\":",
      "                        seen.add((nr, nc))",
      "                        q.append((nr, nc))",
      "",
      "        islands = 0",
      "        for r in range(m):",
      "            for c in range(n):",
      "                if grid[r][c] == \"1\" and (r, c) not in seen:",
      "                    islands += 1",
      "                    bfs(r, c)",
      "",
      "        return islands"
    ],
    "intuition": "Each island is a connected component of '1's. When you find a new land cell, flood-fill to mark its whole component, then count how many times you start a flood-fill."
  },
  "206": {
    "question_name": "Reverse Linked List",
    "general_solution_pattern": "Pointer manipulation",
    "specific_solution_pattern": "Iteratively reverse next pointers with prev/cur",
    "general_type": "Linked List",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def reverseList(self, head):",
      "        prev = None",
      "        cur = head",
      "        while cur:",
      "            nxt = cur.next",
      "            cur.next = prev",
      "            prev = cur",
      "            cur = nxt",
      "        return prev"
    ],
    "intuition": "Walk through the list and flip each arrow to point backward. Keeping a 'prev' pointer prevents losing the already-reversed portion."
  },
  "207": {
    "question_name": "Course Schedule",
    "general_solution_pattern": "Topological sort / cycle detection",
    "specific_solution_pattern": "Kahn's algorithm (BFS on indegree-0 nodes)",
    "general_type": "Graphs",
    "difficulty": "Medium",
    "code_solution": [
      "from collections import deque",
      "",
      "class Solution:",
      "    def canFinish(self, numCourses, prerequisites):",
      "        adj = [[] for _ in range(numCourses)]",
      "        indeg = [0] * numCourses",
      "",
      "        for course, prereq in prerequisites:",
      "            adj[prereq].append(course)",
      "            indeg[course] += 1",
      "",
      "        q = deque([i for i in range(numCourses) if indeg[i] == 0])",
      "        taken = 0",
      "",
      "        while q:",
      "            u = q.popleft()",
      "            taken += 1",
      "            for v in adj[u]:",
      "                indeg[v] -= 1",
      "                if indeg[v] == 0:",
      "                    q.append(v)",
      "",
      "        return taken == numCourses"
    ],
    "intuition": "If there’s a cycle, no node in the cycle can ever reach indegree 0, so you can’t process all courses. If you can remove nodes until all are processed, the graph is acyclic."
  },
  "208": {
    "question_name": "Implement Trie (Prefix Tree)",
    "general_solution_pattern": "Trie / prefix tree",
    "specific_solution_pattern": "Each node holds children map and end-of-word flag",
    "general_type": "Tries",
    "difficulty": "Medium",
    "code_solution": [
      "class TrieNode:",
      "    __slots__ = (\"children\", \"is_end\")",
      "    def __init__(self):",
      "        self.children = {}",
      "        self.is_end = False",
      "",
      "class Trie:",
      "    def __init__(self):",
      "        self.root = TrieNode()",
      "",
      "    def insert(self, word):",
      "        node = self.root",
      "        for ch in word:",
      "            if ch not in node.children:",
      "                node.children[ch] = TrieNode()",
      "            node = node.children[ch]",
      "        node.is_end = True",
      "",
      "    def search(self, word):",
      "        node = self.root",
      "        for ch in word:",
      "            if ch not in node.children:",
      "                return False",
      "            node = node.children[ch]",
      "        return node.is_end",
      "",
      "    def startsWith(self, prefix):",
      "        node = self.root",
      "        for ch in prefix:",
      "            if ch not in node.children:",
      "                return False",
      "            node = node.children[ch]",
      "        return True"
    ],
    "intuition": "A trie stores characters along paths from the root. This makes prefix queries natural: to check a prefix you just walk the prefix characters; to check a word you also require an end marker."
  },
  "211": {
    "question_name": "Design Add and Search Words Data Structure",
    "general_solution_pattern": "Trie + DFS",
    "specific_solution_pattern": "Wildcard '.' branches over all children recursively",
    "general_type": "Tries",
    "difficulty": "Medium",
    "code_solution": [
      "class TrieNode:",
      "    __slots__ = (\"children\", \"is_end\")",
      "    def __init__(self):",
      "        self.children = {}",
      "        self.is_end = False",
      "",
      "class WordDictionary:",
      "    def __init__(self):",
      "        self.root = TrieNode()",
      "",
      "    def addWord(self, word):",
      "        node = self.root",
      "        for ch in word:",
      "            node = node.children.setdefault(ch, TrieNode())",
      "        node.is_end = True",
      "",
      "    def search(self, word):",
      "        def dfs(node, i):",
      "            if i == len(word):",
      "                return node.is_end",
      "            ch = word[i]",
      "            if ch == \".\":",
      "                return any(dfs(child, i + 1) for child in node.children.values())",
      "            if ch not in node.children:",
      "                return False",
      "            return dfs(node.children[ch], i + 1)",
      "",
      "        return dfs(self.root, 0)"
    ],
    "intuition": "A trie handles exact character matches in O(length). The '.' wildcard means “try any next character”, which is naturally a DFS over the trie’s outgoing edges at that position."
  },
  "212": {
    "question_name": "Word Search II",
    "general_solution_pattern": "Trie + backtracking",
    "specific_solution_pattern": "Build trie of words; DFS board guided by trie; prune dead branches",
    "general_type": "Tries",
    "difficulty": "Hard",
    "code_solution": [
      "class TrieNode:",
      "    __slots__ = (\"children\", \"word\")",
      "    def __init__(self):",
      "        self.children = {}",
      "        self.word = None  # store full word at terminal",
      "",
      "class Solution:",
      "    def findWords(self, board, words):",
      "        if not board or not board[0] or not words:",
      "            return []",
      "",
      "        # Build trie",
      "        root = TrieNode()",
      "        for w in words:",
      "            node = root",
      "            for ch in w:",
      "                node = node.children.setdefault(ch, TrieNode())",
      "            node.word = w",
      "",
      "        m, n = len(board), len(board[0])",
      "        res = []",
      "",
      "        def dfs(r, c, parent):",
      "            ch = board[r][c]",
      "            if ch not in parent.children:",
      "                return",
      "            node = parent.children[ch]",
      "",
      "            if node.word is not None:",
      "                res.append(node.word)",
      "                node.word = None  # avoid duplicates",
      "",
      "            board[r][c] = \"#\"",
      "            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):",
      "                nr, nc = r + dr, c + dc",
      "                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] != \"#\":",
      "                    dfs(nr, nc, node)",
      "            board[r][c] = ch",
      "",
      "            # prune leaf nodes to speed up",
      "            if not node.children and node.word is None:",
      "                del parent.children[ch]",
      "",
      "        for r in range(m):",
      "            for c in range(n):",
      "                dfs(r, c, root)",
      "",
      "        return res"
    ],
    "intuition": "Searching each word separately repeats work. A trie lets you share common prefixes: as you walk the board, you simultaneously walk the trie, abandoning paths that aren’t prefixes of any word."
  },
  "213": {
    "question_name": "House Robber II",
    "general_solution_pattern": "DP with case split",
    "specific_solution_pattern": "Run House Robber on [0..n-2] and [1..n-1], take max",
    "general_type": "Dynamic Programming",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def rob(self, nums):",
      "        if not nums:",
      "            return 0",
      "        if len(nums) == 1:",
      "            return nums[0]",
      "",
      "        def linear(arr):",
      "            take = skip = 0",
      "            for x in arr:",
      "                take, skip = skip + x, max(skip, take)",
      "            return max(take, skip)",
      "",
      "        return max(linear(nums[:-1]), linear(nums[1:]))"
    ],
    "intuition": "In a circle, you can’t take both the first and last house. So either you exclude the last (allow first) or exclude the first (allow last); each case becomes the linear problem."
  },
  "217": {
    "question_name": "Contains Duplicate",
    "general_solution_pattern": "Set membership",
    "specific_solution_pattern": "Insert while scanning; detect repeat",
    "general_type": "Arrays & Hashing",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def containsDuplicate(self, nums):",
      "        seen = set()",
      "        for x in nums:",
      "            if x in seen:",
      "                return True",
      "            seen.add(x)",
      "        return False"
    ],
    "intuition": "A set answers “have I seen this value before?” in expected O(1). The first repeated insert proves a duplicate exists."
  },
  "226": {
    "question_name": "Invert Binary Tree",
    "general_solution_pattern": "Tree DFS",
    "specific_solution_pattern": "Swap children recursively",
    "general_type": "Trees",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def invertTree(self, root):",
      "        if not root:",
      "            return None",
      "        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)",
      "        return root"
    ],
    "intuition": "Inverting a tree means every node swaps its left and right child. Doing that recursively inverts the entire structure."
  },
  "230": {
    "question_name": "Kth Smallest Element in a BST",
    "general_solution_pattern": "Inorder traversal",
    "specific_solution_pattern": "Iterative inorder with stack; decrement k on visit",
    "general_type": "Trees",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def kthSmallest(self, root, k):",
      "        stack = []",
      "        cur = root",
      "",
      "        while cur or stack:",
      "            while cur:",
      "                stack.append(cur)",
      "                cur = cur.left",
      "            cur = stack.pop()",
      "            k -= 1",
      "            if k == 0:",
      "                return cur.val",
      "            cur = cur.right"
    ],
    "intuition": "Inorder traversal of a BST visits values in sorted order. The kth visited node is the kth smallest."
  },
  "235": {
    "question_name": "Lowest Common Ancestor of a BST",
    "general_solution_pattern": "BST property / iterative search",
    "specific_solution_pattern": "Walk until values split across current node",
    "general_type": "Trees",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def lowestCommonAncestor(self, root, p, q):",
      "        lo, hi = sorted((p.val, q.val))",
      "        cur = root",
      "        while cur:",
      "            if hi < cur.val:",
      "                cur = cur.left",
      "            elif lo > cur.val:",
      "                cur = cur.right",
      "            else:",
      "                return cur"
    ],
    "intuition": "In a BST, if both targets are smaller than the current node, LCA must be left; if both are larger, it must be right. The first node where they diverge (or equal) is the LCA."
  },
  "238": {
    "question_name": "Product of Array Except Self",
    "general_solution_pattern": "Prefix/suffix accumulation",
    "specific_solution_pattern": "Two passes: prefix products then multiply by suffix products",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def productExceptSelf(self, nums):",
      "        n = len(nums)",
      "        ans = [1] * n",
      "",
      "        prefix = 1",
      "        for i in range(n):",
      "            ans[i] = prefix",
      "            prefix *= nums[i]",
      "",
      "        suffix = 1",
      "        for i in range(n - 1, -1, -1):",
      "            ans[i] *= suffix",
      "            suffix *= nums[i]",
      "",
      "        return ans"
    ],
    "intuition": "For each index i, the answer is (product of everything left of i) * (product of everything right of i). Prefix pass builds the left product; suffix pass supplies the right product without division."
  },
  "242": {
    "question_name": "Valid Anagram",
    "general_solution_pattern": "Frequency counting",
    "specific_solution_pattern": "Compare character counts",
    "general_type": "String",
    "difficulty": "Easy",
    "code_solution": [
      "from collections import Counter",
      "",
      "class Solution:",
      "    def isAnagram(self, s, t):",
      "        return Counter(s) == Counter(t)"
    ],
    "intuition": "Two strings are anagrams iff every character appears the same number of times in both strings."
  },
  "252": {
    "question_name": "Meeting Rooms",
    "general_solution_pattern": "Sort + overlap check",
    "specific_solution_pattern": "Sort by start; ensure each start >= previous end",
    "general_type": "Intervals",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def canAttendMeetings(self, intervals):",
      "        intervals.sort(key=lambda x: x[0])",
      "        for (s1, e1), (s2, e2) in zip(intervals, intervals[1:]):",
      "            if s2 < e1:",
      "                return False",
      "        return True"
    ],
    "intuition": "After sorting by start time, the only way to overlap is with the immediately previous meeting. So you just check consecutive pairs."
  },
  "253": {
    "question_name": "Meeting Rooms II",
    "general_solution_pattern": "Heap / resource allocation",
    "specific_solution_pattern": "Min-heap of end times; reuse room when earliest end <= next start",
    "general_type": "Intervals",
    "difficulty": "Medium",
    "code_solution": [
      "import heapq",
      "",
      "class Solution:",
      "    def minMeetingRooms(self, intervals):",
      "        if not intervals:",
      "            return 0",
      "        intervals.sort(key=lambda x: x[0])",
      "",
      "        ends = []",
      "        for s, e in intervals:",
      "            if ends and ends[0] <= s:",
      "                heapq.heapreplace(ends, e)",
      "            else:",
      "                heapq.heappush(ends, e)",
      "        return len(ends)"
    ],
    "intuition": "A room becomes available when its meeting ends. Tracking the smallest end time lets you reuse a room whenever possible; otherwise you must open a new room."
  },
  "261": {
    "question_name": "Graph Valid Tree",
    "general_solution_pattern": "Union-Find (DSU)",
    "specific_solution_pattern": "Require edges == n-1, union to detect cycles, ensure one component",
    "general_type": "Graphs",
    "difficulty": "Medium",
    "code_solution": [
      "class UnionFind:",
      "    def __init__(self, n):",
      "        self.parent = list(range(n))",
      "        self.size = [1] * n",
      "        self.components = n",
      "",
      "    def find(self, x):",
      "        while x != self.parent[x]:",
      "            self.parent[x] = self.parent[self.parent[x]]",
      "            x = self.parent[x]",
      "        return x",
      "",
      "    def union(self, a, b):",
      "        ra, rb = self.find(a), self.find(b)",
      "        if ra == rb:",
      "            return False",
      "        if self.size[ra] < self.size[rb]:",
      "            ra, rb = rb, ra",
      "        self.parent[rb] = ra",
      "        self.size[ra] += self.size[rb]",
      "        self.components -= 1",
      "        return True",
      "",
      "class Solution:",
      "    def validTree(self, n, edges):",
      "        if len(edges) != n - 1:",
      "            return False",
      "",
      "        uf = UnionFind(n)",
      "        for a, b in edges:",
      "            if not uf.union(a, b):",
      "                return False  # cycle",
      "        return uf.components == 1"
    ],
    "intuition": "A tree must be connected and acyclic. In an undirected graph, having exactly n-1 edges is necessary; union-find then quickly checks for any cycle and whether all nodes end up in one component."
  },
  "268": {
    "question_name": "Missing Number",
    "general_solution_pattern": "XOR invariant",
    "specific_solution_pattern": "xor(0..n) ^ xor(nums)",
    "general_type": "Binary",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def missingNumber(self, nums):",
      "        n = len(nums)",
      "        x = n",
      "        for i, v in enumerate(nums):",
      "            x ^= i ^ v",
      "        return x"
    ],
    "intuition": "XOR cancels equal values. If you XOR all indices 0..n and all numbers present, every number cancels except the missing one."
  },
  "269": {
    "question_name": "Alien Dictionary",
    "general_solution_pattern": "Topological sort from constraints",
    "specific_solution_pattern": "Build precedence graph from adjacent words + Kahn topo; detect invalid prefix/cycles",
    "general_type": "Graphs",
    "difficulty": "Hard",
    "code_solution": [
      "from collections import deque",
      "",
      "class Solution:",
      "    def alienOrder(self, words):",
      "        # Collect all unique characters",
      "        chars = set(\"\".join(words))",
      "        adj = {ch: set() for ch in chars}",
      "        indeg = {ch: 0 for ch in chars}",
      "",
      "        # Build edges from first differing character in adjacent words",
      "        for w1, w2 in zip(words, words[1:]):",
      "            if len(w1) > len(w2) and w1.startswith(w2):",
      "                return \"\"  # invalid ordering",
      "",
      "            for a, b in zip(w1, w2):",
      "                if a != b:",
      "                    if b not in adj[a]:",
      "                        adj[a].add(b)",
      "                        indeg[b] += 1",
      "                    break",
      "",
      "        # Topological sort",
      "        q = deque([ch for ch in chars if indeg[ch] == 0])",
      "        order = []",
      "",
      "        while q:",
      "            ch = q.popleft()",
      "            order.append(ch)",
      "            for nxt in adj[ch]:",
      "                indeg[nxt] -= 1",
      "                if indeg[nxt] == 0:",
      "                    q.append(nxt)",
      "",
      "        return \"\".join(order) if len(order) == len(chars) else \"\""
    ],
    "intuition": "Adjacent words reveal the first character position where they differ, which implies an ordering constraint. Those constraints form a directed graph; a valid alphabet order is any topological ordering (and none exists if there’s a cycle or invalid prefix)."
  },
  "271": {
    "question_name": "Encode and Decode Strings",
    "general_solution_pattern": "Robust encoding",
    "specific_solution_pattern": "Length-prefix each string: '<len>#<string>'",
    "general_type": "String",
    "difficulty": "Medium",
    "code_solution": [
      "class Codec:",
      "    def encode(self, strs):",
      "        return \"\".join(f\"{len(s)}#{s}\" for s in strs)",
      "",
      "    def decode(self, s):",
      "        res = []",
      "        i = 0",
      "        while i < len(s):",
      "            j = i",
      "            while s[j] != \"#\":",
      "                j += 1",
      "            length = int(s[i:j])",
      "            j += 1",
      "            res.append(s[j:j + length])",
      "            i = j + length",
      "        return res"
    ],
    "intuition": "Delimiters alone can appear inside strings, so you need an unambiguous boundary. Prefixing each string with its length tells you exactly how many characters to read next."
  },
  "295": {
    "question_name": "Find Median from Data Stream",
    "general_solution_pattern": "Two heaps",
    "specific_solution_pattern": "Max-heap for lower half (negatives) + min-heap for upper half; keep sizes balanced",
    "general_type": "Arrays & Hashing",
    "difficulty": "Hard",
    "code_solution": [
      "import heapq",
      "",
      "class MedianFinder:",
      "    def __init__(self):",
      "        self.low = []   # max-heap via negatives",
      "        self.high = []  # min-heap",
      "",
      "    def addNum(self, num):",
      "        heapq.heappush(self.low, -num)",
      "",
      "        if self.high and (-self.low[0] > self.high[0]):",
      "            heapq.heappush(self.high, -heapq.heappop(self.low))",
      "",
      "        if len(self.low) > len(self.high) + 1:",
      "            heapq.heappush(self.high, -heapq.heappop(self.low))",
      "        elif len(self.high) > len(self.low):",
      "            heapq.heappush(self.low, -heapq.heappop(self.high))",
      "",
      "    def findMedian(self):",
      "        if len(self.low) > len(self.high):",
      "            return float(-self.low[0])",
      "        return (-self.low[0] + self.high[0]) / 2.0"
    ],
    "intuition": "The median splits the numbers into a lower half and upper half. Keeping the halves in two heaps lets you insert in log n and read the middle elements in O(1)."
  },
  "297": {
    "question_name": "Serialize and Deserialize Binary Tree",
    "general_solution_pattern": "Tree encoding/decoding",
    "specific_solution_pattern": "Preorder with null markers; recursive reconstruction using iterator",
    "general_type": "Trees",
    "difficulty": "Hard",
    "code_solution": [
      "class Codec:",
      "    def serialize(self, root):",
      "        out = []",
      "",
      "        def dfs(node):",
      "            if not node:",
      "                out.append(\"#\")",
      "                return",
      "            out.append(str(node.val))",
      "            dfs(node.left)",
      "            dfs(node.right)",
      "",
      "        dfs(root)",
      "        return \",\".join(out)",
      "",
      "    def deserialize(self, data):",
      "        vals = iter(data.split(\",\"))",
      "",
      "        def dfs():",
      "            v = next(vals)",
      "            if v == \"#\":",
      "                return None",
      "            node = TreeNode(int(v))",
      "            node.left = dfs()",
      "            node.right = dfs()",
      "            return node",
      "",
      "        return dfs()"
    ],
    "intuition": "Preorder traversal records a node before its children; adding a special marker for null makes the structure unambiguous. Deserialization reads the stream in the same preorder order to rebuild the tree."
  },
  "300": {
    "question_name": "Longest Increasing Subsequence",
    "general_solution_pattern": "Greedy + binary search",
    "specific_solution_pattern": "Patience sorting (tails array with bisect_left)",
    "general_type": "Binary Search / Greedy",
    "difficulty": "Medium",
    "code_solution": [
      "import bisect",
      "",
      "class Solution:",
      "    def lengthOfLIS(self, nums):",
      "        tails = []",
      "        for x in nums:",
      "            i = bisect.bisect_left(tails, x)",
      "            if i == len(tails):",
      "                tails.append(x)",
      "            else:",
      "                tails[i] = x",
      "        return len(tails)"
    ],
    "intuition": "tails[k] stores the smallest possible tail of an increasing subsequence of length k+1. Smaller tails are always better because they leave more room to extend later, and binary search finds where each x fits."
  },
  "322": {
    "question_name": "Coin Change",
    "general_solution_pattern": "1D DP (unbounded knapsack)",
    "specific_solution_pattern": "dp[a] = min(dp[a-c]+1) over coins",
    "general_type": "Dynamic Programming",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def coinChange(self, coins, amount):",
      "        INF = amount + 1",
      "        dp = [INF] * (amount + 1)",
      "        dp[0] = 0",
      "",
      "        for a in range(1, amount + 1):",
      "            for c in coins:",
      "                if a - c >= 0:",
      "                    dp[a] = min(dp[a], dp[a - c] + 1)",
      "",
      "        return -1 if dp[amount] == INF else dp[amount]"
    ],
    "intuition": "If the last coin you use has value c, then you must have already formed amount-c. So the best for amount is one plus the best for amount-c, minimized across choices."
  },
  "323": {
    "question_name": "Number of Connected Components in an Undirected Graph",
    "general_solution_pattern": "Union-Find (DSU)",
    "specific_solution_pattern": "Union all edges; remaining DSU component count",
    "general_type": "Graphs",
    "difficulty": "Medium",
    "code_solution": [
      "class UnionFind:",
      "    def __init__(self, n):",
      "        self.parent = list(range(n))",
      "        self.size = [1] * n",
      "        self.components = n",
      "",
      "    def find(self, x):",
      "        while x != self.parent[x]:",
      "            self.parent[x] = self.parent[self.parent[x]]",
      "            x = self.parent[x]",
      "        return x",
      "",
      "    def union(self, a, b):",
      "        ra, rb = self.find(a), self.find(b)",
      "        if ra == rb:",
      "            return",
      "        if self.size[ra] < self.size[rb]:",
      "            ra, rb = rb, ra",
      "        self.parent[rb] = ra",
      "        self.size[ra] += self.size[rb]",
      "        self.components -= 1",
      "",
      "class Solution:",
      "    def countComponents(self, n, edges):",
      "        uf = UnionFind(n)",
      "        for a, b in edges:",
      "            uf.union(a, b)",
      "        return uf.components"
    ],
    "intuition": "Each union merges two components if they were separate. After processing all edges, the number of disjoint sets remaining is exactly the number of connected components."
  },
  "338": {
    "question_name": "Counting Bits",
    "general_solution_pattern": "DP on bits",
    "specific_solution_pattern": "dp[i] = dp[i>>1] + (i&1)",
    "general_type": "Binary",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def countBits(self, n):",
      "        dp = [0] * (n + 1)",
      "        for i in range(1, n + 1):",
      "            dp[i] = dp[i >> 1] + (i & 1)",
      "        return dp"
    ],
    "intuition": "Shifting right by 1 drops the last bit, so i has the same bitcount as i//2 plus 1 if the last bit was 1."
  },
  "347": {
    "question_name": "Top K Frequent Elements",
    "general_solution_pattern": "Counting + bucket sort",
    "specific_solution_pattern": "Bucket numbers by frequency, scan buckets from high to low",
    "general_type": "Arrays & Hashing",
    "difficulty": "Medium",
    "code_solution": [
      "from collections import Counter",
      "",
      "class Solution:",
      "    def topKFrequent(self, nums, k):",
      "        freq = Counter(nums)",
      "        buckets = [[] for _ in range(len(nums) + 1)]",
      "        for val, f in freq.items():",
      "            buckets[f].append(val)",
      "",
      "        res = []",
      "        for f in range(len(nums), 0, -1):",
      "            for val in buckets[f]:",
      "                res.append(val)",
      "                if len(res) == k:",
      "                    return res"
    ],
    "intuition": "If you know each element’s frequency, you can group elements by frequency. The highest-frequency groups are the answer, and bucket sort avoids an extra log factor."
  },
  "371": {
    "question_name": "Sum of Two Integers",
    "general_solution_pattern": "Bit manipulation",
    "specific_solution_pattern": "XOR for sum-without-carry, AND<<1 for carry (32-bit mask)",
    "general_type": "Binary",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def getSum(self, a, b):",
      "        MASK = 0xFFFFFFFF",
      "        SIGN = 0x80000000",
      "",
      "        while b != 0:",
      "            carry = (a & b) << 1",
      "            a = (a ^ b) & MASK",
      "            b = carry & MASK",
      "",
      "        return a if a < SIGN else ~(a ^ MASK)"
    ],
    "intuition": "XOR adds bits ignoring carry; AND finds where carry happens. Repeating 'sum without carry' plus 'carry shifted left' simulates addition. Masking forces 32-bit behavior."
  },
  "417": {
    "question_name": "Pacific Atlantic Water Flow",
    "general_solution_pattern": "Graph traversal on grid (reverse reachability)",
    "specific_solution_pattern": "Multi-source BFS from each ocean moving to >= heights; intersect",
    "general_type": "Graphs",
    "difficulty": "Medium",
    "code_solution": [
      "from collections import deque",
      "",
      "class Solution:",
      "    def pacificAtlantic(self, heights):",
      "        if not heights or not heights[0]:",
      "            return []",
      "",
      "        m, n = len(heights), len(heights[0])",
      "",
      "        def bfs(starts):",
      "            q = deque(starts)",
      "            seen = set(starts)",
      "            while q:",
      "                r, c = q.popleft()",
      "                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):",
      "                    nr, nc = r + dr, c + dc",
      "                    if not (0 <= nr < m and 0 <= nc < n):",
      "                        continue",
      "                    if (nr, nc) in seen:",
      "                        continue",
      "                    if heights[nr][nc] >= heights[r][c]:",
      "                        seen.add((nr, nc))",
      "                        q.append((nr, nc))",
      "            return seen",
      "",
      "        pac = [(0, c) for c in range(n)] + [(r, 0) for r in range(m)]",
      "        atl = [(m - 1, c) for c in range(n)] + [(r, n - 1) for r in range(m)]",
      "",
      "        reach_p = bfs(pac)",
      "        reach_a = bfs(atl)",
      "",
      "        return [[r, c] for (r, c) in (reach_p & reach_a)]"
    ],
    "intuition": "Instead of simulating water flowing downhill from every cell, reverse the direction: start from each ocean and move 'uphill' (to >= height). Cells reachable from both oceans are the answer."
  },
  "424": {
    "question_name": "Longest Repeating Character Replacement",
    "general_solution_pattern": "Sliding window",
    "specific_solution_pattern": "Window valid if (len - max_freq) <= k; shrink when invalid",
    "general_type": "String",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def characterReplacement(self, s, k):",
      "        count = {}",
      "        left = 0",
      "        max_freq = 0",
      "        best = 0",
      "",
      "        for right, ch in enumerate(s):",
      "            count[ch] = count.get(ch, 0) + 1",
      "            max_freq = max(max_freq, count[ch])",
      "",
      "            while (right - left + 1) - max_freq > k:",
      "                count[s[left]] -= 1",
      "                left += 1",
      "",
      "            best = max(best, right - left + 1)",
      "",
      "        return best"
    ],
    "intuition": "To make a window all one letter, you only need to replace the non-majority characters. Tracking the majority count tells you how many replacements are required."
  },
  "435": {
    "question_name": "Non-overlapping Intervals",
    "general_solution_pattern": "Greedy",
    "specific_solution_pattern": "Sort by end; keep earliest finishing intervals to minimize removals",
    "general_type": "Intervals",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def eraseOverlapIntervals(self, intervals):",
      "        if not intervals:",
      "            return 0",
      "        intervals.sort(key=lambda x: x[1])",
      "",
      "        keep_end = intervals[0][1]",
      "        removals = 0",
      "",
      "        for s, e in intervals[1:]:",
      "            if s < keep_end:",
      "                removals += 1",
      "            else:",
      "                keep_end = e",
      "",
      "        return removals"
    ],
    "intuition": "To leave as much room as possible for future intervals, always keep the interval that ends first. This classic greedy choice maximizes how many you can keep (so removals are minimized)."
  },
  "572": {
    "question_name": "Subtree of Another Tree",
    "general_solution_pattern": "Tree serialization + pattern matching",
    "specific_solution_pattern": "Serialize with null markers and run KMP to find subtree serialization",
    "general_type": "Trees",
    "difficulty": "Easy",
    "code_solution": [
      "class Solution:",
      "    def isSubtree(self, root, subRoot):",
      "        def serialize(node, out):",
      "            if not node:",
      "                out.append(\"X\")",
      "                return",
      "            out.append(f\"V{node.val}\")",
      "            serialize(node.left, out)",
      "            serialize(node.right, out)",
      "",
      "        def build_lps(pat):",
      "            lps = [0] * len(pat)",
      "            j = 0",
      "            for i in range(1, len(pat)):",
      "                while j > 0 and pat[i] != pat[j]:",
      "                    j = lps[j - 1]",
      "                if pat[i] == pat[j]:",
      "                    j += 1",
      "                    lps[i] = j",
      "            return lps",
      "",
      "        def kmp(text, pat):",
      "            if not pat:",
      "                return True",
      "            lps = build_lps(pat)",
      "            j = 0",
      "            for x in text:",
      "                while j > 0 and x != pat[j]:",
      "                    j = lps[j - 1]",
      "                if x == pat[j]:",
      "                    j += 1",
      "                    if j == len(pat):",
      "                        return True",
      "            return False",
      "",
      "        t1, t2 = [], []",
      "        serialize(root, t1)",
      "        serialize(subRoot, t2)",
      "        return kmp(t1, t2)"
    ],
    "intuition": "If two trees are identical, their preorder serializations (with null markers) match exactly. So subRoot is a subtree iff its serialization appears as a contiguous subsequence in root’s serialization; KMP finds that in linear time."
  },
  "647": {
    "question_name": "Palindromic Substrings",
    "general_solution_pattern": "String algorithm (Manacher)",
    "specific_solution_pattern": "Compute palindrome radii and sum per-center contributions",
    "general_type": "String",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def countSubstrings(self, s):",
      "        if not s:",
      "            return 0",
      "",
      "        t = \"^#\" + \"#\".join(s) + \"#$\"",
      "        p = [0] * len(t)",
      "        center = right = 0",
      "",
      "        for i in range(1, len(t) - 1):",
      "            mirror = 2 * center - i",
      "            if i < right:",
      "                p[i] = min(right - i, p[mirror])",
      "",
      "            while t[i + 1 + p[i]] == t[i - 1 - p[i]]:",
      "                p[i] += 1",
      "",
      "            if i + p[i] > right:",
      "                center, right = i, i + p[i]",
      "",
      "        # Each radius contributes (radius+1)//2 palindromes in the original string.",
      "        return sum((r + 1) // 2 for r in p)"
    ],
    "intuition": "Every palindrome is centered at some position (or gap). In the transformed string, p[i] tells how far the palindrome extends; that radius directly counts how many original palindromes are centered there."
  },
  "1143": {
    "question_name": "Longest Common Subsequence",
    "general_solution_pattern": "2D DP",
    "specific_solution_pattern": "Rolling row DP for LCS length",
    "general_type": "Dynamic Programming",
    "difficulty": "Medium",
    "code_solution": [
      "class Solution:",
      "    def longestCommonSubsequence(self, text1, text2):",
      "        if len(text2) > len(text1):",
      "            text1, text2 = text2, text1",
      "",
      "        m = len(text2)",
      "        dp = [0] * (m + 1)",
      "",
      "        for i in range(1, len(text1) + 1):",
      "            prev_diag = 0",
      "            for j in range(1, m + 1):",
      "                tmp = dp[j]",
      "                if text1[i - 1] == text2[j - 1]:",
      "                    dp[j] = prev_diag + 1",
      "                else:",
      "                    dp[j] = max(dp[j], dp[j - 1])",
      "                prev_diag = tmp",
      "",
      "        return dp[m]"
    ],
    "intuition": "For prefixes ending at i and j: if chars match, extend the best of (i-1, j-1); otherwise drop one character and take the best of (i-1, j) or (i, j-1). Rolling rows keeps only what you need."
  }
}
