// One-time imported from a local Blind75 solutions snapshot.
// Runtime code only reads this in-repo module.
export const QUESTION_SOLUTION_OVERRIDES = Object.freeze({
  1: Object.freeze({
    leetcodeId: 1,
    answerPattern: "Hash map lookup",
    specificPattern: "Single-pass complement map (value -> index)",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def twoSum(self, nums, target):",
      "        seen = {}",
      "        for i, x in enumerate(nums):",
      "            need = target - x",
      "            if need in seen:",
      "                return [seen[need], i]",
      "            seen[x] = i",
    ]),
    intuition: "As you scan left-to-right, remember where you've seen each value. For the current value x, the only partner that works is target-x; if it was seen earlier, you have the answer immediately.",
  }),
  2: Object.freeze({
    leetcodeId: 242,
    answerPattern: "Frequency counting",
    specificPattern: "Compare character counts",
    solutionType: "String",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "from collections import Counter",
      "",
      "class Solution:",
      "    def isAnagram(self, s, t):",
      "        return Counter(s) == Counter(t)",
    ]),
    intuition: "Two strings are anagrams iff every character appears the same number of times in both strings.",
  }),
  3: Object.freeze({
    leetcodeId: 217,
    answerPattern: "Set membership",
    specificPattern: "Insert while scanning; detect repeat",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def containsDuplicate(self, nums):",
      "        seen = set()",
      "        for x in nums:",
      "            if x in seen:",
      "                return True",
      "            seen.add(x)",
      "        return False",
    ]),
    intuition: "A set answers \"have I seen this value before?\" in expected O(1). The first repeated insert proves a duplicate exists.",
  }),
  4: Object.freeze({
    leetcodeId: 49,
    answerPattern: "Hashing by canonical signature",
    specificPattern: "Use 26-count tuple as key (lowercase letters)",
    solutionType: "String",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "from collections import defaultdict",
      "",
      "class Solution:",
      "    def groupAnagrams(self, strs):",
      "        groups = defaultdict(list)",
      "",
      "        for s in strs:",
      "            counts = [0] * 26",
      "            for ch in s:",
      "                counts[ord(ch) - ord(\"a\")] += 1",
      "            groups[tuple(counts)].append(s)",
      "",
      "        return list(groups.values())",
    ]),
    intuition: "Anagrams share the same multiset of letters. A frequency vector is a canonical representation of that multiset, so it's a perfect hash key.",
  }),
  5: Object.freeze({
    leetcodeId: 347,
    answerPattern: "Counting + bucket sort",
    specificPattern: "Bucket numbers by frequency, scan buckets from high to low",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "from collections import Counter",
      "",
      "class Solution:",
      "    def topKFrequent(self, nums, k):",
      "        freq = Counter(nums)",
      "        buckets = [[] for _ in range(len(nums) + 1)]",
      "        for val, f in freq.items():",
      "            buckets[f].append(val)",
      "",
      "        res = []",
      "        for f in range(len(nums), 0, -1):",
      "            for val in buckets[f]:",
      "                res.append(val)",
      "                if len(res) == k:",
      "                    return res",
    ]),
    intuition: "If you know each element's frequency, you can group elements by frequency. The highest-frequency groups are the answer, and bucket sort avoids an extra log factor.",
  }),
  6: Object.freeze({
    leetcodeId: 238,
    answerPattern: "Prefix/suffix accumulation",
    specificPattern: "Two passes: prefix products then multiply by suffix products",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def productExceptSelf(self, nums):",
      "        n = len(nums)",
      "        ans = [1] * n",
      "",
      "        prefix = 1",
      "        for i in range(n):",
      "            ans[i] = prefix",
      "            prefix *= nums[i]",
      "",
      "        suffix = 1",
      "        for i in range(n - 1, -1, -1):",
      "            ans[i] *= suffix",
      "            suffix *= nums[i]",
      "",
      "        return ans",
    ]),
    intuition: "For each index i, the answer is (product of everything left of i) * (product of everything right of i). Prefix pass builds the left product; suffix pass supplies the right product without division.",
  }),
  7: Object.freeze({
    leetcodeId: 271,
    answerPattern: "Robust encoding",
    specificPattern: "Length-prefix each string: '<len>#<string>'",
    solutionType: "String",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Codec:",
      "    def encode(self, strs):",
      "        return \"\".join(f\"{len(s)}#{s}\" for s in strs)",
      "",
      "    def decode(self, s):",
      "        res = []",
      "        i = 0",
      "        while i < len(s):",
      "            j = i",
      "            while s[j] != \"#\":",
      "                j += 1",
      "            length = int(s[i:j])",
      "            j += 1",
      "            res.append(s[j:j + length])",
      "            i = j + length",
      "        return res",
    ]),
    intuition: "Delimiters alone can appear inside strings, so you need an unambiguous boundary. Prefixing each string with its length tells you exactly how many characters to read next.",
  }),
  8: Object.freeze({
    leetcodeId: 128,
    answerPattern: "Hash set scanning",
    specificPattern: "Only start counting at sequence starts (x-1 not in set)",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def longestConsecutive(self, nums):",
      "        s = set(nums)",
      "        best = 0",
      "        for x in s:",
      "            if x - 1 not in s:",
      "                y = x",
      "                while y in s:",
      "                    y += 1",
      "                best = max(best, y - x)",
      "        return best",
    ]),
    intuition: "If x isn't preceded by x-1, it must be the start of a run. Each number is expanded at most once across all runs, giving linear expected time.",
  }),
  9: Object.freeze({
    leetcodeId: 125,
    answerPattern: "Two pointers",
    specificPattern: "Skip non-alphanumeric and compare lowercase chars",
    solutionType: "String",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def isPalindrome(self, s):",
      "        l, r = 0, len(s) - 1",
      "        while l < r:",
      "            while l < r and not s[l].isalnum():",
      "                l += 1",
      "            while l < r and not s[r].isalnum():",
      "                r -= 1",
      "            if s[l].lower() != s[r].lower():",
      "                return False",
      "            l += 1",
      "            r -= 1",
      "        return True",
    ]),
    intuition: "A palindrome reads the same forward and backward once you ignore irrelevant characters. Two pointers compare mirrored characters while skipping punctuation/spaces.",
  }),
  10: Object.freeze({
    leetcodeId: 15,
    answerPattern: "Sorting + two pointers",
    specificPattern: "Fix one value, then 2-sum sweep with duplicate skipping",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def threeSum(self, nums):",
      "        nums.sort()",
      "        res = []",
      "        n = len(nums)",
      "",
      "        for i in range(n):",
      "            if i > 0 and nums[i] == nums[i - 1]:",
      "                continue",
      "            if nums[i] > 0:",
      "                break",
      "",
      "            l, r = i + 1, n - 1",
      "            while l < r:",
      "                s = nums[i] + nums[l] + nums[r]",
      "                if s == 0:",
      "                    res.append([nums[i], nums[l], nums[r]])",
      "                    l += 1",
      "                    r -= 1",
      "                    while l < r and nums[l] == nums[l - 1]:",
      "                        l += 1",
      "                    while l < r and nums[r] == nums[r + 1]:",
      "                        r -= 1",
      "                elif s < 0:",
      "                    l += 1",
      "                else:",
      "                    r -= 1",
      "",
      "        return res",
    ]),
    intuition: "After sorting, for a fixed i the remaining two numbers must sum to -nums[i]. Two pointers can find those pairs in linear time, and skipping equal values prevents duplicate triplets.",
  }),
  11: Object.freeze({
    leetcodeId: 11,
    answerPattern: "Two pointers + greedy",
    specificPattern: "Move the shorter wall inward",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def maxArea(self, height):",
      "        l, r = 0, len(height) - 1",
      "        best = 0",
      "        while l < r:",
      "            best = max(best, (r - l) * min(height[l], height[r]))",
      "            if height[l] < height[r]:",
      "                l += 1",
      "            else:",
      "                r -= 1",
      "        return best",
    ]),
    intuition: "The area is limited by the shorter line. Moving the taller line can only shrink width without raising the limit, so the only hope is to move the shorter line and possibly find a taller one.",
  }),
  13: Object.freeze({
    leetcodeId: 121,
    answerPattern: "Greedy / running invariant",
    specificPattern: "Track min price so far and best profit",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def maxProfit(self, prices):",
      "        min_price = float(\"inf\")",
      "        best = 0",
      "        for p in prices:",
      "            min_price = min(min_price, p)",
      "            best = max(best, p - min_price)",
      "        return best",
    ]),
    intuition: "If you sell on day i, the best buy day is simply the cheapest day before i. Keeping that minimum price lets you compute the best profit for every possible sell day in O(1).",
  }),
  14: Object.freeze({
    leetcodeId: 3,
    answerPattern: "Sliding window",
    specificPattern: "Last-seen index map; move left past duplicates",
    solutionType: "String",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def lengthOfLongestSubstring(self, s):",
      "        last = {}",
      "        left = 0",
      "        best = 0",
      "",
      "        for right, ch in enumerate(s):",
      "            if ch in last and last[ch] >= left:",
      "                left = last[ch] + 1",
      "            last[ch] = right",
      "            best = max(best, right - left + 1)",
      "",
      "        return best",
    ]),
    intuition: "Maintain a window with all unique chars. When you see a repeated char, the window must jump its left boundary to one past the previous occurrence.",
  }),
  15: Object.freeze({
    leetcodeId: 424,
    answerPattern: "Sliding window",
    specificPattern: "Window valid if (len - max_freq) <= k; shrink when invalid",
    solutionType: "String",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def characterReplacement(self, s, k):",
      "        count = {}",
      "        left = 0",
      "        max_freq = 0",
      "        best = 0",
      "",
      "        for right, ch in enumerate(s):",
      "            count[ch] = count.get(ch, 0) + 1",
      "            max_freq = max(max_freq, count[ch])",
      "",
      "            while (right - left + 1) - max_freq > k:",
      "                count[s[left]] -= 1",
      "                left += 1",
      "",
      "            best = max(best, right - left + 1)",
      "",
      "        return best",
    ]),
    intuition: "To make a window all one letter, you only need to replace the non-majority characters. Tracking the majority count tells you how many replacements are required.",
  }),
  16: Object.freeze({
    leetcodeId: 76,
    answerPattern: "Sliding window with counting",
    specificPattern: "Expand to satisfy counts, then shrink to minimal while valid",
    solutionType: "String",
    sourceDifficulty: "Hard",
    codeSolution: Object.freeze([
      "from collections import Counter",
      "",
      "class Solution:",
      "    def minWindow(self, s, t):",
      "        if not t or not s:",
      "            return \"\"",
      "",
      "        need = Counter(t)",
      "        window = {}",
      "        formed = 0",
      "        required = len(need)",
      "",
      "        best_len = float(\"inf\")",
      "        best_l = 0",
      "",
      "        l = 0",
      "        for r, ch in enumerate(s):",
      "            window[ch] = window.get(ch, 0) + 1",
      "            if ch in need and window[ch] == need[ch]:",
      "                formed += 1",
      "",
      "            while formed == required:",
      "                if r - l + 1 < best_len:",
      "                    best_len = r - l + 1",
      "                    best_l = l",
      "",
      "                left_ch = s[l]",
      "                window[left_ch] -= 1",
      "                if left_ch in need and window[left_ch] < need[left_ch]:",
      "                    formed -= 1",
      "                l += 1",
      "",
      "        return \"\" if best_len == float(\"inf\") else s[best_l:best_l + best_len]",
    ]),
    intuition: "You expand the right end until the window contains all required characters (with multiplicity). Then you shrink from the left as much as possible while staying valid, recording the smallest valid window.",
  }),
  17: Object.freeze({
    leetcodeId: 20,
    answerPattern: "Stack",
    specificPattern: "Push expected closing bracket; pop to match",
    solutionType: "String",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def isValid(self, s):",
      "        match = {\"(\": \")\", \"[\": \"]\", \"{\": \"}\"}",
      "        stack = []",
      "",
      "        for ch in s:",
      "            if ch in match:",
      "                stack.append(match[ch])",
      "            else:",
      "                if not stack or stack.pop() != ch:",
      "                    return False",
      "",
      "        return not stack",
    ]),
    intuition: "The most recent unmatched opening bracket must be closed next (LIFO). Pushing the expected closer makes mismatches easy to detect.",
  }),
  24: Object.freeze({
    leetcodeId: 153,
    answerPattern: "Binary search on rotated invariant",
    specificPattern: "Compare mid vs right to choose side containing pivot",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def findMin(self, nums):",
      "        l, r = 0, len(nums) - 1",
      "        while l < r:",
      "            m = (l + r) // 2",
      "            if nums[m] > nums[r]:",
      "                l = m + 1",
      "            else:",
      "                r = m",
      "        return nums[l]",
    ]),
    intuition: "In a rotated sorted array, one side around mid is still sorted. If nums[mid] > nums[right], the minimum must be to the right of mid; otherwise it's at mid or left of it.",
  }),
  25: Object.freeze({
    leetcodeId: 33,
    answerPattern: "Modified binary search",
    specificPattern: "Identify sorted half; keep half that could contain target",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def search(self, nums, target):",
      "        l, r = 0, len(nums) - 1",
      "        while l <= r:",
      "            m = (l + r) // 2",
      "            if nums[m] == target:",
      "                return m",
      "",
      "            if nums[l] <= nums[m]:  # left half sorted",
      "                if nums[l] <= target < nums[m]:",
      "                    r = m - 1",
      "                else:",
      "                    l = m + 1",
      "            else:  # right half sorted",
      "                if nums[m] < target <= nums[r]:",
      "                    l = m + 1",
      "                else:",
      "                    r = m - 1",
      "        return -1",
    ]),
    intuition: "At any time, at least one side of mid is normally sorted. If the target falls inside that sorted range, you binary search there; otherwise it must be in the other half.",
  }),
  27: Object.freeze({
    leetcodeId: 206,
    answerPattern: "Pointer manipulation",
    specificPattern: "Iteratively reverse next pointers with prev/cur",
    solutionType: "Linked List",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def reverseList(self, head):",
      "        prev = None",
      "        cur = head",
      "        while cur:",
      "            nxt = cur.next",
      "            cur.next = prev",
      "            prev = cur",
      "            cur = nxt",
      "        return prev",
    ]),
    intuition: "Walk through the list and flip each arrow to point backward. Keeping a 'prev' pointer prevents losing the already-reversed portion.",
  }),
  28: Object.freeze({
    leetcodeId: 21,
    answerPattern: "Merge process",
    specificPattern: "Iterative merge with dummy head",
    solutionType: "Linked List",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def mergeTwoLists(self, list1, list2):",
      "        dummy = ListNode(0)",
      "        tail = dummy",
      "",
      "        while list1 and list2:",
      "            if list1.val <= list2.val:",
      "                tail.next, list1 = list1, list1.next",
      "            else:",
      "                tail.next, list2 = list2, list2.next",
      "            tail = tail.next",
      "",
      "        tail.next = list1 or list2",
      "        return dummy.next",
    ]),
    intuition: "Like merging two sorted arrays: repeatedly take the smaller head node and advance that list. A dummy head simplifies edge cases.",
  }),
  29: Object.freeze({
    leetcodeId: 141,
    answerPattern: "Two pointers",
    specificPattern: "Floyd's tortoise-hare cycle detection",
    solutionType: "Linked List",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def hasCycle(self, head):",
      "        slow = fast = head",
      "        while fast and fast.next:",
      "            slow = slow.next",
      "            fast = fast.next.next",
      "            if slow is fast:",
      "                return True",
      "        return False",
    ]),
    intuition: "If there's a cycle, a faster pointer moving 2 steps will eventually lap the slower pointer moving 1 step. If there's no cycle, the fast pointer hits null.",
  }),
  30: Object.freeze({
    leetcodeId: 143,
    answerPattern: "Split + reverse + merge",
    specificPattern: "Find middle, reverse second half, then weave nodes alternating",
    solutionType: "Linked List",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def reorderList(self, head):",
      "        if not head or not head.next:",
      "            return",
      "",
      "        # 1) Find middle",
      "        slow = fast = head",
      "        while fast and fast.next:",
      "            slow = slow.next",
      "            fast = fast.next.next",
      "",
      "        # 2) Reverse second half",
      "        second = slow.next",
      "        slow.next = None",
      "        prev = None",
      "        while second:",
      "            nxt = second.next",
      "            second.next = prev",
      "            prev = second",
      "            second = nxt",
      "        second = prev",
      "",
      "        # 3) Merge alternating",
      "        first = head",
      "        while second:",
      "            f_next = first.next",
      "            s_next = second.next",
      "            first.next = second",
      "            second.next = f_next",
      "            first = f_next",
      "            second = s_next",
    ]),
    intuition: "The desired order is front, back, front, back... So you split the list in half, reverse the back half to make 'back' accessible in forward order, then weave the two lists together.",
  }),
  31: Object.freeze({
    leetcodeId: 19,
    answerPattern: "Two pointers",
    specificPattern: "Maintain a gap of n between fast and slow pointers",
    solutionType: "Linked List",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def removeNthFromEnd(self, head, n):",
      "        dummy = ListNode(0, head)",
      "        fast = slow = dummy",
      "",
      "        for _ in range(n):",
      "            fast = fast.next",
      "",
      "        while fast.next:",
      "            fast = fast.next",
      "            slow = slow.next",
      "",
      "        slow.next = slow.next.next",
      "        return dummy.next",
    ]),
    intuition: "If fast is n nodes ahead of slow, then when fast reaches the end, slow is right before the node to remove. The dummy node makes removing the head node easy.",
  }),
  32: Object.freeze({
    leetcodeId: 23,
    answerPattern: "Heap / k-way merge",
    specificPattern: "Min-heap of (node.val, list_id, node); pop/push next",
    solutionType: "Linked List",
    sourceDifficulty: "Hard",
    codeSolution: Object.freeze([
      "import heapq",
      "",
      "class Solution:",
      "    def mergeKLists(self, lists):",
      "        heap = []",
      "        for i, node in enumerate(lists):",
      "            if node:",
      "                heapq.heappush(heap, (node.val, i, node))",
      "",
      "        dummy = ListNode(0)",
      "        tail = dummy",
      "",
      "        while heap:",
      "            val, i, node = heapq.heappop(heap)",
      "            tail.next = node",
      "            tail = tail.next",
      "            if node.next:",
      "                heapq.heappush(heap, (node.next.val, i, node.next))",
      "",
      "        tail.next = None",
      "        return dummy.next",
    ]),
    intuition: "You always want the smallest current head among k lists. A min-heap gives that in O(log k), and after popping one node you push its successor from the same list.",
  }),
  33: Object.freeze({
    leetcodeId: 226,
    answerPattern: "Tree DFS",
    specificPattern: "Swap children recursively",
    solutionType: "Trees",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def invertTree(self, root):",
      "        if not root:",
      "            return None",
      "        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)",
      "        return root",
    ]),
    intuition: "Inverting a tree means every node swaps its left and right child. Doing that recursively inverts the entire structure.",
  }),
  34: Object.freeze({
    leetcodeId: 104,
    answerPattern: "Tree DFS",
    specificPattern: "Depth = 1 + max(left, right)",
    solutionType: "Trees",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def maxDepth(self, root):",
      "        if not root:",
      "            return 0",
      "        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
    ]),
    intuition: "The deepest path through a node must go through its deeper child. Recursively compute child depths and add 1 for the current node.",
  }),
  35: Object.freeze({
    leetcodeId: 100,
    answerPattern: "Tree recursion",
    specificPattern: "Compare node values and recursively compare subtrees",
    solutionType: "Trees",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def isSameTree(self, p, q):",
      "        if not p and not q:",
      "            return True",
      "        if not p or not q or p.val != q.val:",
      "            return False",
      "        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
    ]),
    intuition: "Two trees are the same iff their roots match and their left subtrees are the same and their right subtrees are the same. Nulls must match too.",
  }),
  36: Object.freeze({
    leetcodeId: 572,
    answerPattern: "Tree serialization + pattern matching",
    specificPattern: "Serialize with null markers and run KMP to find subtree serialization",
    solutionType: "Trees",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def isSubtree(self, root, subRoot):",
      "        def serialize(node, out):",
      "            if not node:",
      "                out.append(\"X\")",
      "                return",
      "            out.append(f\"V{node.val}\")",
      "            serialize(node.left, out)",
      "            serialize(node.right, out)",
      "",
      "        def build_lps(pat):",
      "            lps = [0] * len(pat)",
      "            j = 0",
      "            for i in range(1, len(pat)):",
      "                while j > 0 and pat[i] != pat[j]:",
      "                    j = lps[j - 1]",
      "                if pat[i] == pat[j]:",
      "                    j += 1",
      "                    lps[i] = j",
      "            return lps",
      "",
      "        def kmp(text, pat):",
      "            if not pat:",
      "                return True",
      "            lps = build_lps(pat)",
      "            j = 0",
      "            for x in text:",
      "                while j > 0 and x != pat[j]:",
      "                    j = lps[j - 1]",
      "                if x == pat[j]:",
      "                    j += 1",
      "                    if j == len(pat):",
      "                        return True",
      "            return False",
      "",
      "        t1, t2 = [], []",
      "        serialize(root, t1)",
      "        serialize(subRoot, t2)",
      "        return kmp(t1, t2)",
    ]),
    intuition: "If two trees are identical, their preorder serializations (with null markers) match exactly. So subRoot is a subtree iff its serialization appears as a contiguous subsequence in root's serialization; KMP finds that in linear time.",
  }),
  37: Object.freeze({
    leetcodeId: 235,
    answerPattern: "BST property / iterative search",
    specificPattern: "Walk until values split across current node",
    solutionType: "Trees",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def lowestCommonAncestor(self, root, p, q):",
      "        lo, hi = sorted((p.val, q.val))",
      "        cur = root",
      "        while cur:",
      "            if hi < cur.val:",
      "                cur = cur.left",
      "            elif lo > cur.val:",
      "                cur = cur.right",
      "            else:",
      "                return cur",
    ]),
    intuition: "In a BST, if both targets are smaller than the current node, LCA must be left; if both are larger, it must be right. The first node where they diverge (or equal) is the LCA.",
  }),
  38: Object.freeze({
    leetcodeId: 102,
    answerPattern: "BFS",
    specificPattern: "Queue by levels; process len(queue) nodes per level",
    solutionType: "Trees",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "from collections import deque",
      "",
      "class Solution:",
      "    def levelOrder(self, root):",
      "        if not root:",
      "            return []",
      "",
      "        res = []",
      "        q = deque([root])",
      "",
      "        while q:",
      "            level = []",
      "            for _ in range(len(q)):",
      "                node = q.popleft()",
      "                level.append(node.val)",
      "                if node.left:",
      "                    q.append(node.left)",
      "                if node.right:",
      "                    q.append(node.right)",
      "            res.append(level)",
      "",
      "        return res",
    ]),
    intuition: "BFS visits nodes in increasing depth. If you process exactly the current queue length, you consume one full level before moving to the next.",
  }),
  39: Object.freeze({
    leetcodeId: 98,
    answerPattern: "DFS with invariants",
    specificPattern: "Propagate allowable (min, max) range down the tree",
    solutionType: "Trees",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def isValidBST(self, root):",
      "        def dfs(node, lo, hi):",
      "            if not node:",
      "                return True",
      "            if not (lo < node.val < hi):",
      "                return False",
      "            return dfs(node.left, lo, node.val) and dfs(node.right, node.val, hi)",
      "",
      "        return dfs(root, float(\"-inf\"), float(\"inf\"))",
    ]),
    intuition: "BST rules are global: every node in the left subtree must be < root, not just the direct child. Carrying a valid range down ensures every node respects all ancestors' constraints.",
  }),
  40: Object.freeze({
    leetcodeId: 230,
    answerPattern: "Inorder traversal",
    specificPattern: "Iterative inorder with stack; decrement k on visit",
    solutionType: "Trees",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def kthSmallest(self, root, k):",
      "        stack = []",
      "        cur = root",
      "",
      "        while cur or stack:",
      "            while cur:",
      "                stack.append(cur)",
      "                cur = cur.left",
      "            cur = stack.pop()",
      "            k -= 1",
      "            if k == 0:",
      "                return cur.val",
      "            cur = cur.right",
    ]),
    intuition: "Inorder traversal of a BST visits values in sorted order. The kth visited node is the kth smallest.",
  }),
  41: Object.freeze({
    leetcodeId: 105,
    answerPattern: "Divide & conquer with hashmap",
    specificPattern: "Use inorder index map to split; preorder pointer advances",
    solutionType: "Trees",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def buildTree(self, preorder, inorder):",
      "        idx = {v: i for i, v in enumerate(inorder)}",
      "        pre_i = 0",
      "",
      "        def helper(l, r):",
      "            nonlocal pre_i",
      "            if l > r:",
      "                return None",
      "",
      "            root_val = preorder[pre_i]",
      "            pre_i += 1",
      "            root = TreeNode(root_val)",
      "",
      "            mid = idx[root_val]",
      "            root.left = helper(l, mid - 1)",
      "            root.right = helper(mid + 1, r)",
      "            return root",
      "",
      "        return helper(0, len(inorder) - 1)",
    ]),
    intuition: "Preorder gives you the root first. In inorder, everything left of the root is the left subtree and everything right is the right subtree. A hashmap lets you find that split in O(1) each time.",
  }),
  42: Object.freeze({
    leetcodeId: 124,
    answerPattern: "Tree DP",
    specificPattern: "Postorder gains + global best through each node",
    solutionType: "Trees",
    sourceDifficulty: "Hard",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def maxPathSum(self, root):",
      "        self.best = float(\"-inf\")",
      "",
      "        def gain(node):",
      "            if not node:",
      "                return 0",
      "            left = max(0, gain(node.left))",
      "            right = max(0, gain(node.right))",
      "",
      "            # path that peaks at node",
      "            self.best = max(self.best, node.val + left + right)",
      "",
      "            # best extendable path upward",
      "            return node.val + max(left, right)",
      "",
      "        gain(root)",
      "        return self.best",
    ]),
    intuition: "A maximum path either passes through a node as the highest point (taking best non-negative gains from both sides) or extends upward through one child. Compute 'best extendable gain' while updating a global answer for 'peak' paths.",
  }),
  43: Object.freeze({
    leetcodeId: 297,
    answerPattern: "Tree encoding/decoding",
    specificPattern: "Preorder with null markers; recursive reconstruction using iterator",
    solutionType: "Trees",
    sourceDifficulty: "Hard",
    codeSolution: Object.freeze([
      "class Codec:",
      "    def serialize(self, root):",
      "        out = []",
      "",
      "        def dfs(node):",
      "            if not node:",
      "                out.append(\"#\")",
      "                return",
      "            out.append(str(node.val))",
      "            dfs(node.left)",
      "            dfs(node.right)",
      "",
      "        dfs(root)",
      "        return \",\".join(out)",
      "",
      "    def deserialize(self, data):",
      "        vals = iter(data.split(\",\"))",
      "",
      "        def dfs():",
      "            v = next(vals)",
      "            if v == \"#\":",
      "                return None",
      "            node = TreeNode(int(v))",
      "            node.left = dfs()",
      "            node.right = dfs()",
      "            return node",
      "",
      "        return dfs()",
    ]),
    intuition: "Preorder traversal records a node before its children; adding a special marker for null makes the structure unambiguous. Deserialization reads the stream in the same preorder order to rebuild the tree.",
  }),
  44: Object.freeze({
    leetcodeId: 208,
    answerPattern: "Trie / prefix tree",
    specificPattern: "Each node holds children map and end-of-word flag",
    solutionType: "Tries",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class TrieNode:",
      "    __slots__ = (\"children\", \"is_end\")",
      "    def __init__(self):",
      "        self.children = {}",
      "        self.is_end = False",
      "",
      "class Trie:",
      "    def __init__(self):",
      "        self.root = TrieNode()",
      "",
      "    def insert(self, word):",
      "        node = self.root",
      "        for ch in word:",
      "            if ch not in node.children:",
      "                node.children[ch] = TrieNode()",
      "            node = node.children[ch]",
      "        node.is_end = True",
      "",
      "    def search(self, word):",
      "        node = self.root",
      "        for ch in word:",
      "            if ch not in node.children:",
      "                return False",
      "            node = node.children[ch]",
      "        return node.is_end",
      "",
      "    def startsWith(self, prefix):",
      "        node = self.root",
      "        for ch in prefix:",
      "            if ch not in node.children:",
      "                return False",
      "            node = node.children[ch]",
      "        return True",
    ]),
    intuition: "A trie stores characters along paths from the root. This makes prefix queries natural: to check a prefix you just walk the prefix characters; to check a word you also require an end marker.",
  }),
  45: Object.freeze({
    leetcodeId: 212,
    answerPattern: "Trie + backtracking",
    specificPattern: "Build trie of words; DFS board guided by trie; prune dead branches",
    solutionType: "Tries",
    sourceDifficulty: "Hard",
    codeSolution: Object.freeze([
      "class TrieNode:",
      "    __slots__ = (\"children\", \"word\")",
      "    def __init__(self):",
      "        self.children = {}",
      "        self.word = None  # store full word at terminal",
      "",
      "class Solution:",
      "    def findWords(self, board, words):",
      "        if not board or not board[0] or not words:",
      "            return []",
      "",
      "        # Build trie",
      "        root = TrieNode()",
      "        for w in words:",
      "            node = root",
      "            for ch in w:",
      "                node = node.children.setdefault(ch, TrieNode())",
      "            node.word = w",
      "",
      "        m, n = len(board), len(board[0])",
      "        res = []",
      "",
      "        def dfs(r, c, parent):",
      "            ch = board[r][c]",
      "            if ch not in parent.children:",
      "                return",
      "            node = parent.children[ch]",
      "",
      "            if node.word is not None:",
      "                res.append(node.word)",
      "                node.word = None  # avoid duplicates",
      "",
      "            board[r][c] = \"#\"",
      "            for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):",
      "                nr, nc = r + dr, c + dc",
      "                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] != \"#\":",
      "                    dfs(nr, nc, node)",
      "            board[r][c] = ch",
      "",
      "            # prune leaf nodes to speed up",
      "            if not node.children and node.word is None:",
      "                del parent.children[ch]",
      "",
      "        for r in range(m):",
      "            for c in range(n):",
      "                dfs(r, c, root)",
      "",
      "        return res",
    ]),
    intuition: "Searching each word separately repeats work. A trie lets you share common prefixes: as you walk the board, you simultaneously walk the trie, abandoning paths that aren't prefixes of any word.",
  }),
  46: Object.freeze({
    leetcodeId: 295,
    answerPattern: "Two heaps",
    specificPattern: "Max-heap for lower half (negatives) + min-heap for upper half; keep sizes balanced",
    solutionType: "Heap",
    sourceDifficulty: "Hard",
    codeSolution: Object.freeze([
      "import heapq",
      "",
      "class MedianFinder:",
      "    def __init__(self):",
      "        self.low = []   # max-heap via negatives",
      "        self.high = []  # min-heap",
      "",
      "    def addNum(self, num):",
      "        heapq.heappush(self.low, -num)",
      "",
      "        if self.high and (-self.low[0] > self.high[0]):",
      "            heapq.heappush(self.high, -heapq.heappop(self.low))",
      "",
      "        if len(self.low) > len(self.high) + 1:",
      "            heapq.heappush(self.high, -heapq.heappop(self.low))",
      "        elif len(self.high) > len(self.low):",
      "            heapq.heappush(self.low, -heapq.heappop(self.high))",
      "",
      "    def findMedian(self):",
      "        if len(self.low) > len(self.high):",
      "            return float(-self.low[0])",
      "        return (-self.low[0] + self.high[0]) / 2.0",
    ]),
    intuition: "The median splits the numbers into a lower half and upper half. Keeping the halves in two heaps lets you insert in log n and read the middle elements in O(1).",
  }),
  47: Object.freeze({
    leetcodeId: 39,
    answerPattern: "Backtracking / DFS",
    specificPattern: "Sorted candidates + prune; allow reuse by not advancing index",
    solutionType: "Backtracking",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def combinationSum(self, candidates, target):",
      "        candidates.sort()",
      "        res = []",
      "        path = []",
      "",
      "        def dfs(start, remaining):",
      "            if remaining == 0:",
      "                res.append(path[:])",
      "                return",
      "            for i in range(start, len(candidates)):",
      "                c = candidates[i]",
      "                if c > remaining:",
      "                    break",
      "                path.append(c)",
      "                dfs(i, remaining - c)  # reuse allowed",
      "                path.pop()",
      "",
      "        dfs(0, target)",
      "        return res",
    ]),
    intuition: "You build combinations in non-decreasing order to avoid duplicates. Sorting lets you stop early when a candidate exceeds the remaining target.",
  }),
  48: Object.freeze({
    leetcodeId: 79,
    answerPattern: "Backtracking on grid",
    specificPattern: "DFS from each cell; mark visited in-place and restore",
    solutionType: "Matrix",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def exist(self, board, word):",
      "        if not board or not board[0]:",
      "            return False",
      "",
      "        m, n = len(board), len(board[0])",
      "",
      "        def dfs(r, c, i):",
      "            if i == len(word):",
      "                return True",
      "            if not (0 <= r < m and 0 <= c < n):",
      "                return False",
      "            if board[r][c] != word[i]:",
      "                return False",
      "",
      "            ch = board[r][c]",
      "            board[r][c] = \"#\"  # mark visited",
      "",
      "            found = (dfs(r + 1, c, i + 1) or",
      "                     dfs(r - 1, c, i + 1) or",
      "                     dfs(r, c + 1, i + 1) or",
      "                     dfs(r, c - 1, i + 1))",
      "",
      "            board[r][c] = ch",
      "            return found",
      "",
      "        for r in range(m):",
      "            for c in range(n):",
      "                if dfs(r, c, 0):",
      "                    return True",
      "        return False",
    ]),
    intuition: "Try to match the word character-by-character by walking to neighboring cells. Marking a cell as visited prevents reuse in the same path; restoring it enables other paths to use it.",
  }),
  54: Object.freeze({
    leetcodeId: 200,
    answerPattern: "Connected components on grid",
    specificPattern: "Flood-fill (BFS/DFS) each unvisited land cell",
    solutionType: "Graphs",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "from collections import deque",
      "",
      "class Solution:",
      "    def numIslands(self, grid):",
      "        if not grid or not grid[0]:",
      "            return 0",
      "",
      "        m, n = len(grid), len(grid[0])",
      "        seen = set()",
      "",
      "        def bfs(sr, sc):",
      "            q = deque([(sr, sc)])",
      "            seen.add((sr, sc))",
      "            while q:",
      "                r, c = q.popleft()",
      "                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):",
      "                    nr, nc = r + dr, c + dc",
      "                    if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in seen and grid[nr][nc] == \"1\":",
      "                        seen.add((nr, nc))",
      "                        q.append((nr, nc))",
      "",
      "        islands = 0",
      "        for r in range(m):",
      "            for c in range(n):",
      "                if grid[r][c] == \"1\" and (r, c) not in seen:",
      "                    islands += 1",
      "                    bfs(r, c)",
      "",
      "        return islands",
    ]),
    intuition: "Each island is a connected component of '1's. When you find a new land cell, flood-fill to mark its whole component, then count how many times you start a flood-fill.",
  }),
  55: Object.freeze({
    leetcodeId: 133,
    answerPattern: "Graph traversal + hashmap",
    specificPattern: "BFS/DFS with mapping original node -> cloned node",
    solutionType: "Graphs",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "from collections import deque",
      "",
      "class Solution:",
      "    def cloneGraph(self, node):",
      "        if not node:",
      "            return None",
      "",
      "        clones = {node: type(node)(node.val)}",
      "        q = deque([node])",
      "",
      "        while q:",
      "            cur = q.popleft()",
      "            for nei in cur.neighbors:",
      "                if nei not in clones:",
      "                    clones[nei] = type(node)(nei.val)",
      "                    q.append(nei)",
      "                clones[cur].neighbors.append(clones[nei])",
      "",
      "        return clones[node]",
    ]),
    intuition: "Graphs can have cycles, so you must remember which nodes you've already cloned. The map ensures each original node is cloned once, and edges are recreated by linking clones.",
  }),
  56: Object.freeze({
    leetcodeId: 417,
    answerPattern: "Graph traversal on grid (reverse reachability)",
    specificPattern: "Multi-source BFS from each ocean moving to >= heights; intersect",
    solutionType: "Graphs",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "from collections import deque",
      "",
      "class Solution:",
      "    def pacificAtlantic(self, heights):",
      "        if not heights or not heights[0]:",
      "            return []",
      "",
      "        m, n = len(heights), len(heights[0])",
      "",
      "        def bfs(starts):",
      "            q = deque(starts)",
      "            seen = set(starts)",
      "            while q:",
      "                r, c = q.popleft()",
      "                for dr, dc in ((1,0),(-1,0),(0,1),(0,-1)):",
      "                    nr, nc = r + dr, c + dc",
      "                    if not (0 <= nr < m and 0 <= nc < n):",
      "                        continue",
      "                    if (nr, nc) in seen:",
      "                        continue",
      "                    if heights[nr][nc] >= heights[r][c]:",
      "                        seen.add((nr, nc))",
      "                        q.append((nr, nc))",
      "            return seen",
      "",
      "        pac = [(0, c) for c in range(n)] + [(r, 0) for r in range(m)]",
      "        atl = [(m - 1, c) for c in range(n)] + [(r, n - 1) for r in range(m)]",
      "",
      "        reach_p = bfs(pac)",
      "        reach_a = bfs(atl)",
      "",
      "        return [[r, c] for (r, c) in (reach_p & reach_a)]",
    ]),
    intuition: "Instead of simulating water flowing downhill from every cell, reverse the direction: start from each ocean and move 'uphill' (to >= height). Cells reachable from both oceans are the answer.",
  }),
  57: Object.freeze({
    leetcodeId: 207,
    answerPattern: "Topological sort / cycle detection",
    specificPattern: "Kahn's algorithm (BFS on indegree-0 nodes)",
    solutionType: "Graphs",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "from collections import deque",
      "",
      "class Solution:",
      "    def canFinish(self, numCourses, prerequisites):",
      "        adj = [[] for _ in range(numCourses)]",
      "        indeg = [0] * numCourses",
      "",
      "        for course, prereq in prerequisites:",
      "            adj[prereq].append(course)",
      "            indeg[course] += 1",
      "",
      "        q = deque([i for i in range(numCourses) if indeg[i] == 0])",
      "        taken = 0",
      "",
      "        while q:",
      "            u = q.popleft()",
      "            taken += 1",
      "            for v in adj[u]:",
      "                indeg[v] -= 1",
      "                if indeg[v] == 0:",
      "                    q.append(v)",
      "",
      "        return taken == numCourses",
    ]),
    intuition: "If there's a cycle, no node in the cycle can ever reach indegree 0, so you can't process all courses. If you can remove nodes until all are processed, the graph is acyclic.",
  }),
  59: Object.freeze({
    leetcodeId: 261,
    answerPattern: "Union-Find (DSU)",
    specificPattern: "Require edges == n-1, union to detect cycles, ensure one component",
    solutionType: "Graphs",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class UnionFind:",
      "    def __init__(self, n):",
      "        self.parent = list(range(n))",
      "        self.size = [1] * n",
      "        self.components = n",
      "",
      "    def find(self, x):",
      "        while x != self.parent[x]:",
      "            self.parent[x] = self.parent[self.parent[x]]",
      "            x = self.parent[x]",
      "        return x",
      "",
      "    def union(self, a, b):",
      "        ra, rb = self.find(a), self.find(b)",
      "        if ra == rb:",
      "            return False",
      "        if self.size[ra] < self.size[rb]:",
      "            ra, rb = rb, ra",
      "        self.parent[rb] = ra",
      "        self.size[ra] += self.size[rb]",
      "        self.components -= 1",
      "        return True",
      "",
      "class Solution:",
      "    def validTree(self, n, edges):",
      "        if len(edges) != n - 1:",
      "            return False",
      "",
      "        uf = UnionFind(n)",
      "        for a, b in edges:",
      "            if not uf.union(a, b):",
      "                return False  # cycle",
      "        return uf.components == 1",
    ]),
    intuition: "A tree must be connected and acyclic. In an undirected graph, having exactly n-1 edges is necessary; union-find then quickly checks for any cycle and whether all nodes end up in one component.",
  }),
  60: Object.freeze({
    leetcodeId: 323,
    answerPattern: "Union-Find (DSU)",
    specificPattern: "Union all edges; remaining DSU component count",
    solutionType: "Graphs",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class UnionFind:",
      "    def __init__(self, n):",
      "        self.parent = list(range(n))",
      "        self.size = [1] * n",
      "        self.components = n",
      "",
      "    def find(self, x):",
      "        while x != self.parent[x]:",
      "            self.parent[x] = self.parent[self.parent[x]]",
      "            x = self.parent[x]",
      "        return x",
      "",
      "    def union(self, a, b):",
      "        ra, rb = self.find(a), self.find(b)",
      "        if ra == rb:",
      "            return",
      "        if self.size[ra] < self.size[rb]:",
      "            ra, rb = rb, ra",
      "        self.parent[rb] = ra",
      "        self.size[ra] += self.size[rb]",
      "        self.components -= 1",
      "",
      "class Solution:",
      "    def countComponents(self, n, edges):",
      "        uf = UnionFind(n)",
      "        for a, b in edges:",
      "            uf.union(a, b)",
      "        return uf.components",
    ]),
    intuition: "Each union merges two components if they were separate. After processing all edges, the number of disjoint sets remaining is exactly the number of connected components.",
  }),
  61: Object.freeze({
    leetcodeId: 269,
    answerPattern: "Topological sort from constraints",
    specificPattern: "Build precedence graph from adjacent words + Kahn topo; detect invalid prefix/cycles",
    solutionType: "Graphs",
    sourceDifficulty: "Hard",
    codeSolution: Object.freeze([
      "from collections import deque",
      "",
      "class Solution:",
      "    def alienOrder(self, words):",
      "        # Collect all unique characters",
      "        chars = set(\"\".join(words))",
      "        adj = {ch: set() for ch in chars}",
      "        indeg = {ch: 0 for ch in chars}",
      "",
      "        # Build edges from first differing character in adjacent words",
      "        for w1, w2 in zip(words, words[1:]):",
      "            if len(w1) > len(w2) and w1.startswith(w2):",
      "                return \"\"  # invalid ordering",
      "",
      "            for a, b in zip(w1, w2):",
      "                if a != b:",
      "                    if b not in adj[a]:",
      "                        adj[a].add(b)",
      "                        indeg[b] += 1",
      "                    break",
      "",
      "        # Topological sort",
      "        q = deque([ch for ch in chars if indeg[ch] == 0])",
      "        order = []",
      "",
      "        while q:",
      "            ch = q.popleft()",
      "            order.append(ch)",
      "            for nxt in adj[ch]:",
      "                indeg[nxt] -= 1",
      "                if indeg[nxt] == 0:",
      "                    q.append(nxt)",
      "",
      "        return \"\".join(order) if len(order) == len(chars) else \"\"",
    ]),
    intuition: "Adjacent words reveal the first character position where they differ, which implies an ordering constraint. Those constraints form a directed graph; a valid alphabet order is any topological ordering (and none exists if there's a cycle or invalid prefix).",
  }),
  62: Object.freeze({
    leetcodeId: 70,
    answerPattern: "DP / Fibonacci",
    specificPattern: "ways[i] = ways[i-1] + ways[i-2] with O(1) space",
    solutionType: "Dynamic Programming",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def climbStairs(self, n):",
      "        if n <= 2:",
      "            return n",
      "        a, b = 1, 2",
      "        for _ in range(3, n + 1):",
      "            a, b = b, a + b",
      "        return b",
    ]),
    intuition: "To reach step i, your last move was from i-1 or i-2. So the count is the sum of those counts, which is Fibonacci.",
  }),
  63: Object.freeze({
    leetcodeId: 198,
    answerPattern: "DP (take/skip)",
    specificPattern: "Two variables: take = prev_skip + x, skip = max(prev_take, prev_skip)",
    solutionType: "Dynamic Programming",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def rob(self, nums):",
      "        take = 0",
      "        skip = 0",
      "        for x in nums:",
      "            new_take = skip + x",
      "            new_skip = max(skip, take)",
      "            take, skip = new_take, new_skip",
      "        return max(take, skip)",
    ]),
    intuition: "At each house you either rob it (so you must have skipped the previous) or skip it (so you keep the best so far). This local choice fully captures the constraint.",
  }),
  64: Object.freeze({
    leetcodeId: 213,
    answerPattern: "DP with case split",
    specificPattern: "Run House Robber on [0..n-2] and [1..n-1], take max",
    solutionType: "Dynamic Programming",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def rob(self, nums):",
      "        if not nums:",
      "            return 0",
      "        if len(nums) == 1:",
      "            return nums[0]",
      "",
      "        def linear(arr):",
      "            take = skip = 0",
      "            for x in arr:",
      "                take, skip = skip + x, max(skip, take)",
      "            return max(take, skip)",
      "",
      "        return max(linear(nums[:-1]), linear(nums[1:]))",
    ]),
    intuition: "In a circle, you can't take both the first and last house. So either you exclude the last (allow first) or exclude the first (allow last); each case becomes the linear problem.",
  }),
  65: Object.freeze({
    leetcodeId: 5,
    answerPattern: "String algorithm (Manacher)",
    specificPattern: "Transform with separators; compute palindrome radii in O(n)",
    solutionType: "String",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def longestPalindrome(self, s):",
      "        if not s:",
      "            return \"\"",
      "",
      "        # Transform to handle even/odd uniformly: \"^#a#b#...#$\"",
      "        t = \"^#\" + \"#\".join(s) + \"#$\"",
      "        p = [0] * len(t)",
      "        center = right = 0",
      "",
      "        for i in range(1, len(t) - 1):",
      "            mirror = 2 * center - i",
      "            if i < right:",
      "                p[i] = min(right - i, p[mirror])",
      "",
      "            while t[i + 1 + p[i]] == t[i - 1 - p[i]]:",
      "                p[i] += 1",
      "",
      "            if i + p[i] > right:",
      "                center, right = i, i + p[i]",
      "",
      "        max_len = 0",
      "        center_idx = 0",
      "        for i, r in enumerate(p):",
      "            if r > max_len:",
      "                max_len = r",
      "                center_idx = i",
      "",
      "        start = (center_idx - max_len) // 2",
      "        return s[start:start + max_len]",
    ]),
    intuition: "Manacher's algorithm reuses information from previously found palindromes: a palindrome around center implies a mirrored palindrome on the other side. This lets you expand only when necessary and achieve linear time.",
  }),
  66: Object.freeze({
    leetcodeId: 647,
    answerPattern: "String algorithm (Manacher)",
    specificPattern: "Compute palindrome radii and sum per-center contributions",
    solutionType: "String",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def countSubstrings(self, s):",
      "        if not s:",
      "            return 0",
      "",
      "        t = \"^#\" + \"#\".join(s) + \"#$\"",
      "        p = [0] * len(t)",
      "        center = right = 0",
      "",
      "        for i in range(1, len(t) - 1):",
      "            mirror = 2 * center - i",
      "            if i < right:",
      "                p[i] = min(right - i, p[mirror])",
      "",
      "            while t[i + 1 + p[i]] == t[i - 1 - p[i]]:",
      "                p[i] += 1",
      "",
      "            if i + p[i] > right:",
      "                center, right = i, i + p[i]",
      "",
      "        # Each radius contributes (radius+1)//2 palindromes in the original string.",
      "        return sum((r + 1) // 2 for r in p)",
    ]),
    intuition: "Every palindrome is centered at some position (or gap). In the transformed string, p[i] tells how far the palindrome extends; that radius directly counts how many original palindromes are centered there.",
  }),
  67: Object.freeze({
    leetcodeId: 91,
    answerPattern: "DP over string positions",
    specificPattern: "O(1) space: dp[i]=single-digit + two-digit contributions",
    solutionType: "Dynamic Programming",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def numDecodings(self, s):",
      "        if not s or s[0] == \"0\":",
      "            return 0",
      "",
      "        prev2, prev1 = 1, 1  # dp[i-2], dp[i-1]",
      "",
      "        for i in range(1, len(s)):",
      "            cur = 0",
      "",
      "            if s[i] != \"0\":",
      "                cur += prev1",
      "",
      "            two = int(s[i - 1:i + 1])",
      "            if 10 <= two <= 26:",
      "                cur += prev2",
      "",
      "            prev2, prev1 = prev1, cur",
      "",
      "        return prev1",
    ]),
    intuition: "A valid decode ending at i either uses s[i] as a single letter (if not '0') or uses s[i-1:i+1] as a two-digit letter (10-26). Add the number of ways from the appropriate earlier positions.",
  }),
  68: Object.freeze({
    leetcodeId: 322,
    answerPattern: "1D DP (unbounded knapsack)",
    specificPattern: "dp[a] = min(dp[a-c]+1) over coins",
    solutionType: "Dynamic Programming",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def coinChange(self, coins, amount):",
      "        INF = amount + 1",
      "        dp = [INF] * (amount + 1)",
      "        dp[0] = 0",
      "",
      "        for a in range(1, amount + 1):",
      "            for c in coins:",
      "                if a - c >= 0:",
      "                    dp[a] = min(dp[a], dp[a - c] + 1)",
      "",
      "        return -1 if dp[amount] == INF else dp[amount]",
    ]),
    intuition: "If the last coin you use has value c, then you must have already formed amount-c. So the best for amount is one plus the best for amount-c, minimized across choices.",
  }),
  69: Object.freeze({
    leetcodeId: 152,
    answerPattern: "Dynamic programming (track extremes)",
    specificPattern: "Maintain max and min product ending at i (swap on negative)",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def maxProduct(self, nums):",
      "        cur_max = cur_min = best = nums[0]",
      "        for x in nums[1:]:",
      "            if x < 0:",
      "                cur_max, cur_min = cur_min, cur_max",
      "            cur_max = max(x, cur_max * x)",
      "            cur_min = min(x, cur_min * x)",
      "            best = max(best, cur_max)",
      "        return best",
    ]),
    intuition: "A negative number can turn a small (very negative) product into the largest positive product. So you must track both the best and worst product ending at each position.",
  }),
  70: Object.freeze({
    leetcodeId: 139,
    answerPattern: "DP feasibility",
    specificPattern: "dp[i]=True if some dp[j] and s[j:i] in dict (bounded by max word length)",
    solutionType: "Dynamic Programming",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def wordBreak(self, s, wordDict):",
      "        words = set(wordDict)",
      "        max_len = max((len(w) for w in words), default=0)",
      "",
      "        dp = [False] * (len(s) + 1)",
      "        dp[0] = True",
      "",
      "        for i in range(1, len(s) + 1):",
      "            for j in range(max(0, i - max_len), i):",
      "                if dp[j] and s[j:i] in words:",
      "                    dp[i] = True",
      "                    break",
      "",
      "        return dp[len(s)]",
    ]),
    intuition: "dp[i] answers: can we segment the prefix s[:i]? If the last word ends at i and starts at j, then we need dp[j] and s[j:i] to be a dictionary word.",
  }),
  71: Object.freeze({
    leetcodeId: 300,
    answerPattern: "Greedy + binary search",
    specificPattern: "Patience sorting (tails array with bisect_left)",
    solutionType: "Binary Search / Greedy",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "import bisect",
      "",
      "class Solution:",
      "    def lengthOfLIS(self, nums):",
      "        tails = []",
      "        for x in nums:",
      "            i = bisect.bisect_left(tails, x)",
      "            if i == len(tails):",
      "                tails.append(x)",
      "            else:",
      "                tails[i] = x",
      "        return len(tails)",
    ]),
    intuition: "tails[k] stores the smallest possible tail of an increasing subsequence of length k+1. Smaller tails are always better because they leave more room to extend later, and binary search finds where each x fits.",
  }),
  72: Object.freeze({
    leetcodeId: 62,
    answerPattern: "Combinatorics / DP",
    specificPattern: "Compute binomial coefficient C((m+n-2),(m-1)) iteratively",
    solutionType: "Dynamic Programming",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def uniquePaths(self, m, n):",
      "        total = (m - 1) + (n - 1)",
      "        k = min(m - 1, n - 1)",
      "        res = 1",
      "        for i in range(1, k + 1):",
      "            res = res * (total - k + i) // i",
      "        return res",
    ]),
    intuition: "Any path is a sequence of (m-1) downs and (n-1) rights in some order. Choosing which positions are downs uniquely determines the path.",
  }),
  73: Object.freeze({
    leetcodeId: 55,
    answerPattern: "Greedy reachability",
    specificPattern: "Track farthest reachable index; fail if i > farthest",
    solutionType: "Greedy",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def canJump(self, nums):",
      "        farthest = 0",
      "        for i, jump in enumerate(nums):",
      "            if i > farthest:",
      "                return False",
      "            farthest = max(farthest, i + jump)",
      "        return True",
    ]),
    intuition: "You don't need to decide exact jumps; you only need to know the farthest index you can reach so far. If you ever land on an index beyond that, it's unreachable.",
  }),
  74: Object.freeze({
    leetcodeId: 57,
    answerPattern: "Interval sweep/merge",
    specificPattern: "Add non-overlapping left, merge overlaps with new interval, then add right",
    solutionType: "Intervals",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def insert(self, intervals, newInterval):",
      "        res = []",
      "        i = 0",
      "        n = len(intervals)",
      "",
      "        # intervals completely before newInterval",
      "        while i < n and intervals[i][1] < newInterval[0]:",
      "            res.append(intervals[i])",
      "            i += 1",
      "",
      "        # merge overlaps",
      "        start, end = newInterval",
      "        while i < n and intervals[i][0] <= end:",
      "            start = min(start, intervals[i][0])",
      "            end = max(end, intervals[i][1])",
      "            i += 1",
      "        res.append([start, end])",
      "",
      "        # intervals after",
      "        while i < n:",
      "            res.append(intervals[i])",
      "            i += 1",
      "",
      "        return res",
    ]),
    intuition: "Because intervals are sorted and non-overlapping, you can process them in order: everything before the new interval stays as-is, everything overlapping merges into one, and everything after stays as-is.",
  }),
  75: Object.freeze({
    leetcodeId: 56,
    answerPattern: "Sort + merge sweep",
    specificPattern: "Sort by start; merge into last if overlapping",
    solutionType: "Intervals",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def merge(self, intervals):",
      "        if not intervals:",
      "            return []",
      "        intervals.sort(key=lambda x: x[0])",
      "        res = [intervals[0]]",
      "        for s, e in intervals[1:]:",
      "            if s <= res[-1][1]:",
      "                res[-1][1] = max(res[-1][1], e)",
      "            else:",
      "                res.append([s, e])",
      "        return res",
    ]),
    intuition: "After sorting by start time, any overlap can only happen with the most recently merged interval. So a single pass is enough.",
  }),
  76: Object.freeze({
    leetcodeId: 435,
    answerPattern: "Greedy",
    specificPattern: "Sort by end; keep earliest finishing intervals to minimize removals",
    solutionType: "Intervals",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def eraseOverlapIntervals(self, intervals):",
      "        if not intervals:",
      "            return 0",
      "        intervals.sort(key=lambda x: x[1])",
      "",
      "        keep_end = intervals[0][1]",
      "        removals = 0",
      "",
      "        for s, e in intervals[1:]:",
      "            if s < keep_end:",
      "                removals += 1",
      "            else:",
      "                keep_end = e",
      "",
      "        return removals",
    ]),
    intuition: "To leave as much room as possible for future intervals, always keep the interval that ends first. This classic greedy choice maximizes how many you can keep (so removals are minimized).",
  }),
  77: Object.freeze({
    leetcodeId: 252,
    answerPattern: "Sort + overlap check",
    specificPattern: "Sort by start; ensure each start >= previous end",
    solutionType: "Intervals",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def canAttendMeetings(self, intervals):",
      "        intervals.sort(key=lambda x: x[0])",
      "        for (s1, e1), (s2, e2) in zip(intervals, intervals[1:]):",
      "            if s2 < e1:",
      "                return False",
      "        return True",
    ]),
    intuition: "After sorting by start time, the only way to overlap is with the immediately previous meeting. So you just check consecutive pairs.",
  }),
  78: Object.freeze({
    leetcodeId: 253,
    answerPattern: "Heap / resource allocation",
    specificPattern: "Min-heap of end times; reuse room when earliest end <= next start",
    solutionType: "Intervals",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "import heapq",
      "",
      "class Solution:",
      "    def minMeetingRooms(self, intervals):",
      "        if not intervals:",
      "            return 0",
      "        intervals.sort(key=lambda x: x[0])",
      "",
      "        ends = []",
      "        for s, e in intervals:",
      "            if ends and ends[0] <= s:",
      "                heapq.heapreplace(ends, e)",
      "            else:",
      "                heapq.heappush(ends, e)",
      "        return len(ends)",
    ]),
    intuition: "A room becomes available when its meeting ends. Tracking the smallest end time lets you reuse a room whenever possible; otherwise you must open a new room.",
  }),
  79: Object.freeze({
    leetcodeId: 53,
    answerPattern: "Dynamic programming (1D) / Kadane",
    specificPattern: "Best subarray ending here = max(start new, extend)",
    solutionType: "Arrays & Hashing",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def maxSubArray(self, nums):",
      "        best_end = nums[0]",
      "        best = nums[0]",
      "        for x in nums[1:]:",
      "            best_end = max(x, best_end + x)",
      "            best = max(best, best_end)",
      "        return best",
    ]),
    intuition: "A subarray either helps you (positive sum so far) or hurts you (negative sum so far). If the running sum becomes worse than starting fresh at x, you restart; track the best seen.",
  }),
  80: Object.freeze({
    leetcodeId: 191,
    answerPattern: "Bit trick",
    specificPattern: "Brian Kernighan: n &= n-1 clears lowest set bit",
    solutionType: "Binary",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def hammingWeight(self, n):",
      "        count = 0",
      "        while n:",
      "            n &= n - 1",
      "            count += 1",
      "        return count",
    ]),
    intuition: "Subtracting 1 flips the lowest 1-bit to 0 (and turns trailing zeros into ones). ANDing with the original clears exactly that lowest 1-bit, so the loop runs once per set bit.",
  }),
  81: Object.freeze({
    leetcodeId: 338,
    answerPattern: "DP on bits",
    specificPattern: "dp[i] = dp[i>>1] + (i&1)",
    solutionType: "Binary",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def countBits(self, n):",
      "        dp = [0] * (n + 1)",
      "        for i in range(1, n + 1):",
      "            dp[i] = dp[i >> 1] + (i & 1)",
      "        return dp",
    ]),
    intuition: "Shifting right by 1 drops the last bit, so i has the same bitcount as i//2 plus 1 if the last bit was 1.",
  }),
  82: Object.freeze({
    leetcodeId: 190,
    answerPattern: "Bit manipulation",
    specificPattern: "Shift-accumulate for 32 steps",
    solutionType: "Binary",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def reverseBits(self, n):",
      "        res = 0",
      "        for _ in range(32):",
      "            res = (res << 1) | (n & 1)",
      "            n >>= 1",
      "        return res",
    ]),
    intuition: "Read bits from right to left (n&1) and build the reversed number by shifting the result left and appending the next bit.",
  }),
  83: Object.freeze({
    leetcodeId: 268,
    answerPattern: "XOR invariant",
    specificPattern: "xor(0..n) ^ xor(nums)",
    solutionType: "Binary",
    sourceDifficulty: "Easy",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def missingNumber(self, nums):",
      "        n = len(nums)",
      "        x = n",
      "        for i, v in enumerate(nums):",
      "            x ^= i ^ v",
      "        return x",
    ]),
    intuition: "XOR cancels equal values. If you XOR all indices 0..n and all numbers present, every number cancels except the missing one.",
  }),
  84: Object.freeze({
    leetcodeId: 371,
    answerPattern: "Bit manipulation",
    specificPattern: "XOR for sum-without-carry, AND<<1 for carry (32-bit mask)",
    solutionType: "Binary",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def getSum(self, a, b):",
      "        MASK = 0xFFFFFFFF",
      "        SIGN = 0x80000000",
      "",
      "        while b != 0:",
      "            carry = (a & b) << 1",
      "            a = (a ^ b) & MASK",
      "            b = carry & MASK",
      "",
      "        return a if a < SIGN else ~(a ^ MASK)",
    ]),
    intuition: "XOR adds bits ignoring carry; AND finds where carry happens. Repeating 'sum without carry' plus 'carry shifted left' simulates addition. Masking forces 32-bit behavior.",
  }),
  85: Object.freeze({
    leetcodeId: 48,
    answerPattern: "In-place matrix transform",
    specificPattern: "Transpose then reverse each row",
    solutionType: "Matrix",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def rotate(self, matrix):",
      "        n = len(matrix)",
      "",
      "        for r in range(n):",
      "            for c in range(r + 1, n):",
      "                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]",
      "",
      "        for r in range(n):",
      "            matrix[r].reverse()",
    ]),
    intuition: "A 90 degrees clockwise rotation equals reflecting across the main diagonal (transpose) and then reflecting each row horizontally (reverse).",
  }),
  86: Object.freeze({
    leetcodeId: 54,
    answerPattern: "Boundary simulation",
    specificPattern: "Shrink top/bottom/left/right bounds layer by layer",
    solutionType: "Matrix",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def spiralOrder(self, matrix):",
      "        if not matrix or not matrix[0]:",
      "            return []",
      "",
      "        top, bottom = 0, len(matrix) - 1",
      "        left, right = 0, len(matrix[0]) - 1",
      "        res = []",
      "",
      "        while top <= bottom and left <= right:",
      "            for c in range(left, right + 1):",
      "                res.append(matrix[top][c])",
      "            top += 1",
      "",
      "            for r in range(top, bottom + 1):",
      "                res.append(matrix[r][right])",
      "            right -= 1",
      "",
      "            if top <= bottom:",
      "                for c in range(right, left - 1, -1):",
      "                    res.append(matrix[bottom][c])",
      "                bottom -= 1",
      "",
      "            if left <= right:",
      "                for r in range(bottom, top - 1, -1):",
      "                    res.append(matrix[r][left])",
      "                left += 1",
      "",
      "        return res",
    ]),
    intuition: "A spiral is just repeatedly taking the top row, right column, bottom row, and left column, then moving the boundaries inward.",
  }),
  87: Object.freeze({
    leetcodeId: 73,
    answerPattern: "In-place marking",
    specificPattern: "Use first row/col as markers + two flags",
    solutionType: "Matrix",
    sourceDifficulty: "Medium",
    codeSolution: Object.freeze([
      "class Solution:",
      "    def setZeroes(self, matrix):",
      "        m, n = len(matrix), len(matrix[0])",
      "",
      "        first_row_zero = any(matrix[0][c] == 0 for c in range(n))",
      "        first_col_zero = any(matrix[r][0] == 0 for r in range(m))",
      "",
      "        for r in range(1, m):",
      "            for c in range(1, n):",
      "                if matrix[r][c] == 0:",
      "                    matrix[r][0] = 0",
      "                    matrix[0][c] = 0",
      "",
      "        for r in range(1, m):",
      "            for c in range(1, n):",
      "                if matrix[r][0] == 0 or matrix[0][c] == 0:",
      "                    matrix[r][c] = 0",
      "",
      "        if first_row_zero:",
      "            for c in range(n):",
      "                matrix[0][c] = 0",
      "        if first_col_zero:",
      "            for r in range(m):",
      "                matrix[r][0] = 0",
    ]),
    intuition: "Rows/cols that must become zero can be 'remembered' using the first cell of that row/col as a flag, avoiding extra memory. Two separate flags protect the original state of the first row/col.",
  }),
});

export function getQuestionSolutionOverride(questionId) {
  const normalizedQuestionId = Number(questionId);
  if (!Number.isInteger(normalizedQuestionId) || normalizedQuestionId <= 0) return null;
  return QUESTION_SOLUTION_OVERRIDES[normalizedQuestionId] || null;
}
